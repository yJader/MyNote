# 第一章 引论

## 1.1 什么是编译程序

#### 常见的程序

==翻译程序==(Translator)：把某一种语言程序(源语言程序)，翻译成等价的、用另一种语言编写的程序(目标语言程序)的程序，同时报告源程序中的错误。

<img src="./编译原理.assets/image-20240227162440372.png" alt="image-20240227162440372" style="zoom: 33%;" />

==编译程序==(compiler)： 把某一种高级语言程序等价地转换成另一种低级语言程序(如**汇编语言或机器语言**程序)的程序。(c, c++)

<img src="./编译原理.assets/image-20240227162452416.png" alt="image-20240227162452416" style="zoom: 33%;" />

==解释程序==：把源语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源程序本身。(python)

<img src="./编译原理.assets/image-20240227162544768.png" alt="image-20240227162544768" style="zoom:33%;" />



反编译器(decompiler)：进行编译器的反向操作，把一个程序由较低的抽象形式（机器可读）转成较高的抽象形式（人工可读）。
源语言为低级语言，目标语言为高级语言。
源到源的翻译器：把一种高级语言翻译成为另一种高级语言。

## 1.2 为什么要学习编译原理



## 1.3 编译程序的结构

编译器由两个部分组成
==分析部分（前端）==：将源程序分解成中间表示。若分析过程检查出源程序没有按照正确的语法构成，或语义上不一致，它必须提供有用的信息，使用户可以进行改正。分析部分还会收集有关信息，信息存放在符号表中。

==综合部分/合成部分（后端）==：根据中间表示和符号表信息来构建目标程序。

<img src="./编译原理.assets/image-20240227170503977.png" alt="image-20240227170503977" style="zoom: 33%;" /> 

注意: 

- 每个过程都可能出现错误
- 在最开始时就需要实现**符号管理表** 

> 早期编译器中每个流程都比较均衡
>
> 现代编译器中使用了工具, 词法(FLEX), 语法(BISON)分析环节很少, 有较长的语义分析阶段, **非常大的优化阶段**, 一个小代码生成阶段



### 编译流程

#### ①==词法分析==

1. 任务：从左到右扫描源程序的字符流，识别出==词素==（lexeme），并将其抽象成==词法单元==（token）`<种别码，属性值>`

   - **分词**

2. 遵循的原则：构词规则

   - | 单词类型 | 种别                                                         | 种别码               |
     | -------- | ------------------------------------------------------------ | -------------------- |
     | 关键     | program、if、else、then、…                                   | 一词一码             |
     | 标识符   | 变量名、数组名、记录名、过程名、…                            | **多词一码**         |
     | 常量     | 整型、浮点型、字符型、布尔型、…                              | 一型一码             |
     | 运算符   | 算术（  + - * /   ++ -- ）  <br />关系（ >   <  ==  !=  >=  <= ）  <br />逻辑（  &   \|  ~ ） | 一词一码 或 一型一码 |
     | 界限符   | ;  (   ) =  { } …                                            | 一词一码             |

3. 描述工具：有穷自动机

4. 例: 赋值语句

   - ![image-20240227171503821](./编译原理.assets/image-20240227171503821.png) 
   - 
   - **空白，换行等将被忽略**

#### ②==语法分析==

1. 任务:根据语言的语法规则，从词法分析器输出的token序列中识别出==各类短语（语法单位）==，并构造==语法分析树(parse tree)==。
2. 语法分析树描述了句子的语法结构,通过语法分析确定整个输入串是否构成一个语法上正确的程序。
3. 遵循的原则：语法规则
4. 描述工具：**上下文无关文法**
5. 例
   - <img src="./编译原理.assets/image-20240227172234614.png" alt="image-20240227172234614" style="zoom: 33%;" />
   - 树是基于语言的文法来构建的
   - <img src="./编译原理.assets/image-20240227172253475.png" alt="image-20240227172253475" style="zoom:33%;" />



#### ③==语义分析==

1. 任务:
   - 语义检查：使用**语法树和符号表**中的信息来检查源程序是否和语言定义的语义一致。
   - 收集标识符的属性信息（种属、类型、长度等），将信息存放在语法树或符号表中。
   - **类型检查**是一个重要组成部分，它检查每个运算符是否具有匹配的运算分量。
   - 发现语义错误，并支持代码生成
2. 输出为==注释树==：分析树被标记上语义动作
   - <img src="./编译原理.assets/image-20240227172445234.png" alt="image-20240227172445234" style="zoom:33%;" /> 
3. 

#### ④==中间代码生成== END

> 常被包括到语义分析中
>
> 本次课只介绍到这里

1. 任务:对各类语法单位按语言的**语义**进行初步翻译。中间代码应易于生成，且容易被翻译成目标机器的语言。

2. 遵循的原则：语义规则

3. 描述工具：属性文法

4. 中间代码：三元式、四元式、树等

5. 例: 三地址指令：由类似于汇编语言的指令序列组成每个指令最多有三个操作数

   - <img src="./编译原理.assets/image-20240227172639842.png" alt="image-20240227172639842" style="zoom: 33%;" />

6. 常用的三地址指令及其四元式表示

   - | 序号 | 指令类型         | 指令形式                      | 四元式                                                       |
     | ---- | ---------------- | ----------------------------- | ------------------------------------------------------------ |
     | 1    | 赋值指令         | x = y op z     x = op y       | (  op  , y , z   , x  )  (  op  , y , _ , x )                |
     | 2    | 复制指令         | x = y                         | (   = , y   , _ , x )                                        |
     | 3    | 条件跳转         | if x relop y goto n           | (  relop  , x   , y   ,   n )                                |
     | 4    | 非条件跳转       | goto n                        | (  goto  , _ , _  , n  )                                     |
     | 5    | 参数传递         | param x                       | (param, _ , _  , x  )                                        |
     | 6    | 过程调用         | call p, n                     | (call,  p , n , _  )                                         |
     | 7    | 过程返回         | return   x                    | (  return, _  , _  ,  x  )                                   |
     | 8    | 数组引用         | x = y[i]                      | (  =[]  ,   y , i  ,   x  )                                  |
     | 9    | 数组赋值         | x[i] = y                      | (  []=  ,   y , x  ,   i  )                                  |
     | 10   | 地址及  指针操作 | x =& y     x =\* y     *x = y | (  & , y  , _  ,  x  )  (  =\*  , y  , _  ,  x  )  (  *=  , y  , _  ,  x  ) |

#### ⑤优化

1. 任务：对于前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码。
2. 遵循的原则：程序的等价变换规则，主要包括：公共子表达式的提取、循环优化、删除无用代码等等。

#### ⑥目标代码生成

1. 任务: 把中间代码变换成特定机器上的目标代码。
2. 依赖于硬件系统结构和机器指令的含义。
3. 目标代码三种形式:
   - 绝对指令代码: 可直接运行 
   - 可重新定位指令代码: 需要连接装配
   - 汇编指令代码: 需要进行汇编



### 符号表管理和错误处理

1. 符号表管理
   - 保存记号的信息（存储空间、类型、作用域）
   - 在分析、综合过程中使用/修改
   - <img src="./编译原理.assets/image-20240227174842161.png" alt="image-20240227174842161" style="zoom:50%;" /> 
     符号表是用于存放标识符的属性信息的数据结构
2. 错误处理：
   - 发现源程序中的错误，把错误信息报告给用户
   - 发现哪些错误?
     - 语法错误：非法标识符、括号不匹配……
     - 语义错误：变量未声明、类型不一致……
   - 发现错误后如何处理?

### 遍 pass

- 所谓"遍"，就是对源程序或源程序的中间结果从头到尾扫描一次，进行加工，产生新的中间结果或目标程序。
- 阶段与遍是不同的概念。一遍可以由若干阶段组成，一个阶段也可以分若干遍来完成。
- 有单遍编译器，也有多遍编译器。单遍费内存，多遍耗时间。想获取更高的优化效果一般需要多遍。



# 第2章 一个简单的语法制导翻译器

## 2.1 什么是语法制导翻译

编译器**前端**的工作(即**分析阶段**)就是将源程序划分成多个组成部分, 生成源程序的内部表示形式(==中间代码==); **后端**(即合成阶段)将中间代码翻译为目标程序

1. 编译器前端模型
   - <img src="./编译原理.assets/image-20240305200813552.png" alt="image-20240305200813552" style="zoom: 33%;" /> 
2. 编译器的前端的各个阶段围绕待编译语言的“**语法**”展开。
   - 程序设计语言的**语法**描述
     - 描述语言的**正确**构成形式
     - 工具：==上下文无关文法==
   - 程序设计语言的**语义**
     - 描述语言的含义，即**功能**

### 文法描述的几个基本概念

- ==字母表==: 一个有穷字符集，记为$∑$
- ∑上的**字符**：字母表∑中每个元素
- ∑上的**字符串**：指由∑中的字符所**构成**的一个有穷字符序列 (可以重复用)
  - 字符串的长度：符号的个数， 如|aab|=3
  - 空串：不包含任何字符的序列，记为$ε$
- 用$∑^*$表示∑上的所有字符串的**全体**，包含空字ε
  - 例: 设 ∑={a， b}，则 ∑*={ε,a,b,aa,ab,ba,bb,aaa,...}

- ∑*的子集U和V的连接（积）定义为$UV＝\{ αβ | α \in U \& β\in V \} $ (笛卡尔积)
  - 例: 设 U＝{ a, aa } ，V＝ { b, bb }, 则UV ={ ab, abb, aab, aabb}
- V自身的n次积记为：$V^n=V V…V$
  - $V^0={ε}$
  - $V^*是V的克林闭包：V^*=V^0∪V^1∪V^2∪V^3∪… $
  - $V^+是V的正规闭包：V^＋＝V V^*$ 当V中没有ε时, V^+^比V^*^少一个ε
  - <img src="./编译原理.assets/image-20240305204500354.png" alt="image-20240305204500354" style="zoom:50%;" /> 

## 2.2 语法定义

==上下文无关文法==: 简称==文法==, 用于描述程序设计语言语法的表示方法, 用于组织编译器前端

### 2.2.1 文法定义

定义上下文无关文法(context-free grammer, G)为一个四元组$G(V_T, V_N, P, S)$

- $V_T$: ==终结符==(terminal)集（非空） 
  - 文法所定义的语言的基本符号的集合
  - 仅出现在**产生式**右部（体）
  - 例：VT ={ He,a,gave,book,me}
- $V_N$ ：==非终结符==(non-terminal)集（非空）
  - 表示语法成分的符号，有时也称为“ **语法变量**”
  - 在某个产生式的左部出现过的文法符号
  - 例：VN ={ <句子>,<主语>,<谓语>,......}
    程序语言中有 <语句>、<表达式>、<程序>等
  - $V_T \cap V_N = \empty;\quad V_T∪V_N = 文法符号集$

- $S$：==开始符号==(start symbol)
  - 特殊的非终结符，表示该文法中最大的语法成分
  - 例：S = <句子>
  - 两种说明方式：
    - 明确指出
    - 第1条产生式规则左部的文法符号
  - $S\in V_N$ 
- $P$：==产生式==(production)==集==
  - 也称重写规则或规则：描述语言的语法结构的形式规则
  - 一般形式： $α→β$，读作：α**定义**为β
  - α是一个**符号**，称为**左部**或**头**。$α∈V_N$
    β是**有穷符号串**，称为**右部**或**体**。$β∈(V_T∪V_N)^*$

例2-5: 定义只含`+`,`*`的算术表达式的文法

<img src="./编译原理.assets/image-20240305210649977.png" alt="image-20240305210649977" style="zoom:50%;" /> 

### 2.2.2 推导**Derivation**

- 给定文法$G(V_T, V_N, P, S)$，若$A \rightarrow γ\in P $且$α,β (V_T \cup V_N)*$ ，则文法符号串$αAβ$**可重写**为$α γ β$，记作$αAβ \Rightarrow αγβ$，称**$αAβ$直接推导**$αγβ$。

- 如果$α_1\Rightarrow α_2\Rightarrow ...\Rightarrow α_n$，则称这个序列是从$α_1到α_n$的一个**推导**。
  若存在一个从$α_1到α_n$的推导，则称$α_1$可以推导出$α_n$ 。

<img src="./编译原理.assets/image-20240305211905485.png" alt="image-20240305211905485" style="zoom:33%;" />

- 推导长度：执行一步推导的次数
  - 一步推导$\Rightarrow$
  - 1步或若干步的推导 $\Rightarrow ^+$
  - 0步或若干步的推导 $\Rightarrow^*$
    <img src="./编译原理.assets/image-20240305212037713.png" alt="image-20240305212037713" style="zoom:25%;" />

### 2.2.3 文法和语言

1. 文法定义的**==语言==**：从**开始符号**出发，利用推导能得到的所有**终结符号串**的集合。

   - 如果$S \Rightarrow^* α，α∈(V_T∪V_N)*$，则α为文法G的句型

   - 如果$S \Rightarrow^+ w$ (终结符号串)，则w为文法G的句子

   - 文法G的句子集合称为==文法G生成的语言==，记为<font color = 66ccff>$L(G) = \{α|S\Rightarrow α, α\in V_T^*\}$</font>

   - 上下文无关文法生成的语言称为==上下文无关语言==

2. >  练2-4 请证明$ (i*i+i)$是文法$G(E)： E \rightarrow i | E+E | E*E | (E) $的一个句子。

   - 证明：$E \Rightarrow (E) 
     		   \Rightarrow (E+E)
           		   \Rightarrow (E*E+E)
           		   \Rightarrow (i*E+E)
           		   \Rightarrow (i*i+E) 
           		   \Rightarrow (i*i+i)$
     $(i*i+i)是文法G的句子E，(E)，(E*E+E)，…，(i*i+i)是句型。$


3. 文法和语言的关系

   - 给定一个文法，就从结构上**唯一地确定**其语言

   - 给定一种语言，能确定其文法，但文法**不唯一**

4. 等价文法
   - 设$G_1$和$G_2$是两个文法，若$L(G_1)=L(G_2)$，则称$G_1$与$G_2$为等价文法。

5. > 例2-7  设文法 $G(A)：A \rightarrow c | Ab$, G(A)产生的语言是什么？

   - 以c开头，后继若干个b即 L(G)={c，cb，cbb，……}
     称为**递归文法**

6. > 练2-5  设文法$ G(S)：S \rightarrow AB, A \rightarrow aA|a, B \rightarrow bB|b$
   > 	G(S)产生的语言是什么？

   - $L(G)=\{a^mb^n|m，n>0\}$

7. > 例2-8  请给出产生语言为$\{a^nb^n|n\geq1\}$的文法

   - 递推方法：
     - 满足条件最简单的句子是 ab $G(S): S\rightarrow ab$
     - 若S是满足条件的句子，则在S左右分别添加a和b，即$aSb$也满足条件。$S\rightarrow aSb$
   - 递归方法：
     - 若S是满足条件的句子，则拿掉S开头a和结尾b也满足条件$S\rightarrow aSb$，一直到最简单的句子ab。$S\rightarrow ab$

8. **语法分析的任务**：输入终结符号串，找出从开始符号推导出该串的方法

   - > 例2-9 如下文法对串`9-5+2`的推导
     > $	list \Rightarrow list + digit  \Rightarrow list - digit + digit  
     >      	\Rightarrow digit - digit + digit\\  
     > 		\Rightarrow 9 - digit + digit  
     >      	\Rightarrow 9 - 5 + digit   \Rightarrow 9 - 5 + 2$

### 2.2.4 语法分析树

从一个句型到一个句型的推导往往不唯一，可以以**图形方式**描述一个句子的推导过程，称为**语法分析树（简称语法树）**。

某一文法的语法树应具有以下性质：

- 根节点是**开始符号**
- 叶节点是**终结符**（ token）和 **ε**
- 内部节点（非叶结点）是**非终结符**
- 如果应用了规则$A \rightarrow x_1x_2…x_n$, 则A是内部结点;  $x_1 , x_2 , … ，x_n$是其**从左到右**的子结点（内部节点或叶节点）

<img src="./编译原理.assets/image-20240305214146092.png" alt="image-20240305214146092" style="zoom:50%;" />

### 2.2.5 二义性Ambiguous

> 例2-11 文法 $G(E)：E→i|E+E|E*E|(E) $句子$(i*i+i)$的语法树

<img src="./编译原理.assets/image-20240305214433329.png" alt="image-20240305214433329" style="zoom: 33%;" /> 

**该文法是二义性文法**

#### 什么是二义性

==文法的二义性==：如果一个文法存在某个句子对应**两棵不同的语法树**，则说这个**文法是二义**的。

- 本门课程只讨论文法二义性, 不涉及语义二义性
  - 语义二义性: Jack said Tom left **his** assignment at home.

> 例2-12 证明：文法$S \rightarrow  aSbS | bSaS | ε $是二义的

证：对于串abab存在**两棵不同的分析树**：
<img src="./编译原理.assets/image-20240305214556543.png" alt="image-20240305214556543" style="zoom:33%;" /> 

#### 二义性的产生原因

1. >  例2-13 $string \Rightarrow  string + string | string – string | 0 | 1 | …| 9$

   - 解：9-5+2存在两棵不同的分析树，是二义性文法
     <img src="./编译原理.assets/image-20240305214655716.png" alt="image-20240305214655716" style="zoom:33%;" />

   - 左树: 先9-5=4, 再4+2=6
     右树: 先5+2=7, 再9-7=2 计算顺序错误

   - 造成二义性的原因：文法中没有体现出**结合率**和**优先级**

2. 可以基于**优先级**和**结合性**构建无二义的文法

   - 四则运算存在两个优先级，所以可引入两个非终结符expr和term来对应不同的运算层次
     在这个文法中, term会比expr+term, expr-term先进行计算, 即优先度高

   - 四则运算均为左结合，因此在每条规则中，**更为抽象**的非终结符应位于左边
     <img src="./编译原理.assets/image-20240305215019979.png" alt="image-20240305215019979" style="zoom: 33%;" />

3. 程序设计语言中的上下文无关文法

#### 2.2.6 最左推导&最右推导

1. ==最左推导==（Leftmost derivation） : 首先替换最左边的非终结符
   ==最右推导==（rightmost derivation） : 首先替换最右边的非终结符
2. 最左（右）推导与**分析树**一一对应

   - 即, **最左(右)推导可以用来判断文法二义性**

     - 可以通过说明对于某一个串存在两个不同的最左推导来证明文法二义
- 可以通过说明对于某一个串存在两个不同的最右推导来证明文法二义



## 2.3 语法制导翻译

- 采用文法来指导对程序的翻译过程。
- 通过向一个文法的产生式附加一些规则或程序片段来实现。
- ==语法制导定义==和==翻译方案==分别描述了两种不同的附加规则或程序片段的方法。

### 2.3.1 语法制导定义

1. 让每个**文法符号**与一个**属性集合**相关联
   - 属性：文法符号的一些特征。
     如:表达式的属性可以有类型、值等。
2. 让每个**产生式**与一组**语义规则**相关联
   - 语义规则用于计算与该产生式的文法符号相关联的属性的值

3. ==注释分析树==：在结点上**标记相应的属性值**的语法分析树。
   <img src="./编译原理.assets/image-20240308201244395.png" alt="image-20240308201244395" style="zoom: 33%;" />
4. ==综合属性==：如果某属性在语法分析树结点N上的值是由N的子结点以及N本身的属性值确定的，这个属性称为综合属性。
   - 注释方法：先构建分析树，然后注释。
   - 如果只存在综合属性，则只需要对分析树进行一次后续遍历，就可以算出各个结点的属性值。

### 2.3.2 语法制导翻译方案

1. 语法制导翻译方案: 常简称为==翻译方案==。它将语义动作直接**嵌入**到产生式规则中

   - 语义动作：嵌入到产生式内的程序片段（`{...}`）
   - 翻译方案指定了语义动作的执行顺序。

2. 画出一个翻译方案的语法分析树时，要同时描述语义信息：为每个语义动作分别构造一个额外的**子结点**，并用虚线将它和该产生式头部对应的结点相连。(树多了个叉)

   - >  例2-17 把表达式翻译成后缀形式的语义动作

     - expr  →  expr1 + term  { print('+') }
       expr  →  expr1 -  term   { print('-') }
       expr  →  term
       term →  0  { print ('0') }
       term →  1  { print('1') }
            . . .
       term →  9  { print ('9') }
     - <img src="./编译原理.assets/image-20240308201804801.png" alt="image-20240308201804801" style="zoom: 40%;" />

#### 例

例2-18：分别构建一个**语法制导定义**和**翻译方案**，把算术表达式从中缀表示翻译成前缀表示。并给出输入9-5+2和9-5*2时的注释分析树。

##### 语法制导定义实现

<img src="./编译原理.assets/image-20240310123519998.png" alt="image-20240310123519998" style="zoom:33%;" />

<img src="./编译原理.assets/image-20240310123554022.png" alt="image-20240310123554022" style="zoom:33%;" />

##### 翻译方案实现

<img src="./编译原理.assets/image-20240310123633569.png" alt="image-20240310123633569" style="zoom:33%;" />

<img src="./编译原理.assets/image-20240310123641451.png" alt="image-20240310123641451" style="zoom: 33%;" /><img src="./编译原理.assets/image-20240310123650681.png" alt="image-20240310123650681" style="zoom:33%;" />



## 2.4 语法分析

1. 功能：确定如何使用文法生成（推导）一个终结符号串（句子）的过程。
   - 目的: 检查词法分析输出的单词序列是否是源语言的语法规则
2. 语法分析方法分类：
   - ==自顶向下==：从**根结点**开始，逐步向叶子结点方向进行构造 $\begin{cases}递归下降法\\预测分析法\\LL文法 \end{cases}$
   - ==自底向上==：从**叶子结点**开始，逐步构造出根结点。
3. 语法分析器构造方法
   - 手工构造：人工编程实现分析器。支持自顶向下分析
   - 自动构造：形式化地描述文法，分析器构造程序自动将描述转为分析程序。支持自顶向下和自底向上分析

### 2.4.1 自顶向下分析法

1. 从标号为开始符号的根结点开始，反复执行以下两个步骤

   - **扩展结点**：在标号为非终结符号A的结点N上，选择A的一个产生式，并为该产生式体中的各个符号构造出N的子结点

   - **确定待扩展结点**：寻找下一个结点来构造子树，通常选择当前语法分析树中**最左边**的尚未扩展的非终结符。

2. 自顶向下分析实际上是一种**试探性**的过程，可能导致分析效率极低甚至失败。**通常，在自顶向下的分析过程中会遇到二义性问题、左递归引起的无限推导和回溯问题。**

### 2.4.2 递归下降分析法

1. 一般性的自顶向下分析方法。使用一组**递归过程**来处理输入，文法的每一个非终结符都关联一个过程。

   - 非终结符选择产生式是一个“尝试并犯错”的过程。即首先选择一个产生式，不合适时进行回溯，再尝试另一个产生式。

2. > 例2-20 考虑文法$E→T | T+ E\\ T→ int | int * T | ( E )　$　　
   > 给出递归下降法分析(int)的过程。



### 2.4.3 预测分析法

1. 是递归下降分析法的一种简单形式
   - 要求：每个非终结符对应的过程中的控制流（选择哪个产生式）都可以通过**向前看一个符号**（输入中当前被扫描的终结符）来确定。
   - 分析输入串时出现的**过程调用序列** 对应 先序遍历该输入串的一棵语法分析树。

2. 例: 一个预测分析机的伪代码

   - ```pseudocode
     S →  +SS  |  -SS | a
     void s( ) {
         switch (lookahead ) {
             case + :  match('+'); s( ); s( ); break;
             case - :   match('-'); s( );  s( ); break;
             case a :  match ('a'); break;
             default: report ("syntax error");
          }
     }
     ```

   - 例: -+a+aaa
     1. lookahead=-, 选择2, 进入递归层1
        1. `lookahea`d=+, 选择1, 进入递归层2
           1. lookahead=a, 选择3 返回
           2. lookahead=+, 选择1, 进入递归层3
              1. lookahead=a, 选择3 返回
              2. lookahead=a, 选择3 返回
     2. lookahead=a, 选择3 返回

   

### 2.4.4 预测分析法的问题: 左递归

当产生式出现“左递归”时，递归下降语法分析器会进入**无限循环**。

==左递归==：产生式体的最左边的符号和产生式头部相同， 如$  A  → Aα | β   (α≠ ε, β不以A开头)$	

> 例2-23  算术表达式的文法        $S →E\\E→E+T|T\\T→T*F|F\\F→(E)|id$ 
> 为句子id*id+id构造分析树

- <img src="./编译原理.assets/image-20240310125347248.png" alt="image-20240310125347248" style="zoom:33%;" /> 若E()决定使用E→E+T，因为产生式体的开头为E，E()将被递归调用。

#### 左递归的消除

- $  A  → Aα | β   (α≠ ε, β不以A开头)$最后生成的语言形式: $\beta a^* (^*: 正则, 代表任意多个)$

- 上面的产生式进行左递归的消除: $A\rightarrow \beta A'\\A'\rightarrow αA'|\varepsilon$

<img src="./编译原理.assets/image-20240312161159943.png" alt="image-20240312161159943" style="zoom:50%;" /> 

$E→a|-a|E+a|E-a消除左递归$

- $E→ E(+a|-a)|(+a|-a)$

> 练2-9  消除文法G(P)的左递归
> 	P →（Q）|aP|a
> 	Q →Q ,P|P

- $P →（Q）|\textcolor{red}{aP|a} \\ Q→PQ'\\Q'→,PQ|\varepsilon$
- 对于这题, 当lookahead=a时, 会无法确定选择aP还是a, 需要再往后看一个

### 2.4.5 预测分析法问题:回溯

非终结符选择产生式是一个“尝试并犯错”的过程。即首先选择一个产生式，不合适时进行回溯，再尝试另一个产生式。
当出现形如 $A→ αβ_1|αβ_2$的产生式，此时无法确认应该选择A的哪个产生式，可以通过改写产生式(提取左公因子)来推后这个决定，等获得足够信息后再做出正确的选择。

- $A→ αβ_1|αβ_2\quad 变为\quad \begin{cases}A→αA'\\A'→β_1|β_2\end{cases}$ 

> 例2-26 文法	 $E → E' | E' + E\\E' → -E' | id | (E)$
> 用预测分析法分析id+id 

解：

- 提取左公共因子
  	E → E' | E' + E  变为  	$E → E'A\\A→ ε | + E\\E' → -E' | id | (E)$
- $ E \Rightarrow E'A \Rightarrow id A \Rightarrow  id + E \Rightarrow id + E'A
    		    \Rightarrow id + idA \Rightarrow id + id$ 



------

往后为实验内容

------

# 第3章 词法分析

> 词法分析主要任务: 读入源程序输入字符, 将字符组成词素, 生成并输出一个词法分析序列, 每个词法单元对于一个词素

词法分析的任务：从左向右逐行扫描源程序的字符，识别出各个单词，确定**单词的类型**。并将识别出的单词转换成统一的**机内表示**——词法单元(token)形式

编译程序是在单词的级别上来分析和翻译源程序，因此，词法分析是编译的基础



## 3.1 词法分析器的作用

### 3.1.1 词法分析器的作用

1. 读入源程序
2. 去除注释、空格、制表符、换行符等
3. 建立符号表
4. **识别词素，抽象成记号** (`<单词种别，单词的值>`)
5. 将记号插入符号表
6. 发现词法错误，建立错误消息与源程序的**位置**联系
7. 将记号提交给语法分析器

- 完成功能越多越好



### 3.1.2 词素识别实例



### 3.1.3 词法分析的输出

1. 词法分析器的输出：
   - `<单词种别，单词自身的值>`
2. 程序语言单词的分类：
   - **关键字**(保留字或基本字)：如while, if
   - **标识符**：用来表示各种名字，如变量名、数组名
     - 由字母/数字/下划线组成, 字母或下划线开头
   - **常数**：各种类型的常数 256，3.14
   - **运算符**：如，＋、－、*、/
   - **分界符**：如逗号，分号，冒号

3. 单词种别通常用整数编码表示
   - 界符和运算符: **一符一码**
   - 关键字可分成一类，也可以一个关键字分成一类。**一字一码**
   - 常数可统归一类，也可按类型（整型、实型、布尔型等），每个类型的常数划分成一类。**一类型一码**
   - 所有的标识符分为一类。**一类一码**
   - TODO: 画个表格吧
4. 单词的属性值
   - 对于关键字、分界符、运算符来说，它们的单词种别就可以表示其完整的信息，故对于这类单词，其单词自身的值通常为空
   - 对于标识符，词类编码所反映的信息不够充分，标识符的具体特性还要通过单词自身的值进行互相区分。标识符的单词自身的属性常用其在符号表中的入口指针来表示
   - 对于常数，其单词自身的值常用其在常数表中的入口指针来表示

5. | 单词分类              | 编码方式              | 属性值           |
   | --------------------- | --------------------- | ---------------- |
   | 关键字(保留字/基本字) | 一字一码 (一种关键字) | null             |
   | 标识符                | 一类一码              | 符号表的入口指针 |
   | 常数                  | 一类型一码            | 常数表的入口指针 |
   | 运算符                | 一符一码              | null             |
   | 分界符                | 一符一码              | null             |

   

### 3.1.4 词法分析术语

1. ==记号（词法单元、单词） Token== 
   - 具有独立含义的**最小语法单位**，每个记号代表一类符号串
   - 例:  `<identifier>`, `<number>`
2. ==模式Pattern==: 描述某个记号的词素集合的**构造规则**
3. ==词素Lexeme==
   - 源程序的符号序列，可匹配某个记号的模式
   - 标识符: x, count, name, etc…



### 3.1.5 词法错误

1. 当前输入的前缀无法匹配任何记号时报词法错误，如：
   - 出现了当前语言中不会出现的字符，如 @ 或 #
   - 整数越界
   - 标识符名太长(有些语言最大长度为32个字符)
   - 字符串太长(有些语言最大长度为256个字符) 
   - 字符串跨行
2. 局部化 
   - 例: `whil  ( x = 0 ) do  ` 并不产生词法错误



### 3.1.6 双缓冲双指针策略

1. 提高源程序读入速度的策略

2. 采用大块存储空间作为缓存，一次性将大批数据读入缓存

3. 采用双缓冲

   - 在一个缓冲I/O, 另一缓冲词法分析, 第一块用完后, 继续读第二块, 保证连续性

   - ```pseudocode
     switch (*forward++ ) {
         case eof:
     	      if (forward is at end of first buffer ) {
     		reload second buffer;
     		forward = beginning of second buffer;
     	     }
     	    else if (forward is at end of second buffer ) {
     		reload first buffer;
     		forward = beginning of first buffer;
     }
     	   else /* eof within a buffer marks the end of input */
     		terminate lexical analysis;
     	   break;
          cases for the other characters: ......
     }
     
     ```

### 3.1.7 词法分析的设计形式

1. 设计成一个独立程序，完成词法分析的任务，结果以文件的形式组织，做为语法分析的输入
   <img src="./编译原理.assets/image-20240312200018493.png" alt="image-20240312200018493" style="zoom:33%;" /> 
2. 作为语法分析的子程序
   <img src="./编译原理.assets/image-20240312200039623.png" alt="image-20240312200039623" style="zoom:33%;" /> 

### 3.1.8 词法分析器的构造策略

1. 使用传统的程序设计语言手工编写
2. 使用汇编语言手工编写
3. 使用**词法分析器生成器**，从基于**正则表达式**的说明自动产生
   - 例: FLEX



## 3.2 词法分析机的手工实现

### 3.2.1 识别模式

1. 标识符识别
   - 字母开头的字母数字串，后跟界符或算符
2. 常数识别
   - 口识出算术常数并将其转变为二进制内码表示。
   - 5.88, 5.E08
3. 算符和界符的识别
   - 把多个字符符合而成的算符和界符拼合成一个单一单词符号
   - ++, 

### 3.2.2 状态转换图

1. 状态转换图是一张有向图，用来描述和识别记号
2. 包括:
   - **结点**：代表状态States，用圆圈表示
   - **有向边**：代表动作Actions，边上的标记（字符）表示射出状态下可能出现的输入字符（字符类别）
   - **初态**Start State：模式的开始，无源箭头的目标
   - **终态**Final State(s)：模式的结束，双圈
     - 可能带有`*`, 表示输入需要回退一个位置, 意思是当前输入不是当前词素的一部分
   - 一张转换图包含有限个状态，其中有一个为初始状态，有若干个终止状态

### 3.2.3 词法分析器的手工实现

## 3.3 词法分析器的自动生成

### 3.3.1 字母表和串

1. 字母表$∑$ ：符号的有穷集合
   1. 例：{0,1},  {a,b,c},  {n,m, … , z}
2. 串（字）：基于给定字母表的有穷符号序列
   - 例：0011，abbca，AABBC …
3. 串的长度：串S中的符号的数，记为|S|
4. 串的运算：连接、幂
5. 用$∑^*$表示$\sum$上所有串的**全体**，包含空串ε

### 3.3.2 串的术语

> 原始串: banana

- **前缀Prefix**:从尾部删除0或多个符号得到的串。ban, banana, ε
- **后缀Suffix**:从首部删除0或多个符号得到的串。ana, banana, ε
- **子串Substring**:删除某个前缀和某个后缀后得到的串。 nan, ban, ana, banana, ε
  - 真前缀：不等于原串，也不为ε的前缀
    真后缀、真子串：与上类似
- **子序列Subsequence**:删除0或多个符号所得的串。bnan, nn, ε

- > 例3-6 试说明字符串abcdefghij，分别有多少个前缀、后缀、真前缀、子串和子序列。

  - <img src="./编译原理.assets/image-20240319220312990.png" alt="image-20240319220312990" style="zoom:50%;" />

### 3.3.3 语言上的运算

<img src="./编译原理.assets/image-20240319220454320.png" alt="image-20240319220454320" style="zoom:50%;" />

例：令L={A，B，…，Z，a，b，…，z}，D={0，1，…，9}。则L(L∪D)*表示的语言是标识符(数字/字母组成, 且字母开头)

### 3.3.4 正则表达式&语言(正则集)

##### 正则基本定义

1. ==正则表达式==(Regular Expression，RE)，又名正则式、正规表达式、正规式。是一种用来描述词素模式的 更紧凑的表示方法

   - 正则表达式可以由较小的正则表达式按照特定规则递归地构建
   - 例<img src="./编译原理.assets/dec2c475f36fa32cf9bfd8d65b513ce3.png" alt="dec2c475f36fa32cf9bfd8d65b513ce3" style="zoom:50%;" />
   - 基于字母表$\Sigma$​构造串的一组规则（模板、模式）

2. 如果r是正则式，则`L(r)`是r描述的语言（正规集、正则集）

   - L()被称为Mapping Function, 实现语法(syntax)→语义(semantics)的映射

   - 基于同一个字母表，可以通过不同的正则式来定义不同的语言

3. **正则表达式定义**

   - **空串**: ε是正则式，L(ε)={ε}
   - **单字符**: 若$a∈\Sigma$, 则a是正则式， L(a)={a}
   - 若r和s为正则式，且L(r)和L(s)为对应语言。  则
     - **Union**: `r|s`是正则式，L(r|s)  =  L(r)  L(s)
     - **Concatenation**: `rs `是正则式，L(rs)  =  L(r) L(s)
     - **Interaction**: `r*` 是正则式，L(r*)  =  (L(r))*
     - `(r)`是正则式，L((r))=L(r)
   - 以上运算均左结合，优先级从高到低为：`*， 连接，|`

4. 仅由有限次使用上述步骤（3个构造运算）定义的表达式才是$\Sigma$上的正则式，仅由这些正则式表示的串的集合称为==正则语言（正则集）==。
   所有词法结构一般都可以用正则集描述，它们就是词法分析时的**词素**。

##### 一堆例题

1. <img src="./编译原理.assets/c9363fd149b3084276e0eb81957c957c.png" alt="c9363fd149b3084276e0eb81957c957c" style="zoom: 60%;" /> 
2. <img src="./编译原理.assets/image-20240319221233433.png" alt="image-20240319221233433" style="zoom: 33%;" /> 



##### 正则表达式的代数定律

- <img src="./编译原理.assets/7336e408b9eaf3705a8f0d10f23ea489.png" alt="7336e408b9eaf3705a8f0d10f23ea489" style="zoom: 67%;" />

##### 正则表达式的拓展

- `+` : 1个或多个      	
  - $r^* = r^+ | ε且r^+ = rr^*$
- `?` : 0或1个		
  - $r^? = r  | ε$
- `[range] `: 字符的范围
  $A | B | C | … | Z = [ABC…Z] = [A-Z]$

##### 正则定义

==正则定义==是具有如下形式的定义序列：

​		$		d_1→r_1\\
​		d_2→r_2\\
​		   …\\
​		d_n→r_n$
 其中：

- 每个$d_i$都是一个新符号，它们都不在字母表 Σ中，而且各不相同
- 每个ri是字母表 Σ∪{d1 ,d2 , … ,di-1}上的正则表达式

**省流**: 给一些RE命名，并在之后的RE中像使用字母表中的符号一样使用这些名字($d_i$)

- 如C语言中标识符的正则定义

  ```tex
  digit → [0-9]
  letter_ → [A-Za-z_]
  id → letter_(letter_|digit)*
  ```

  

### 3.3.5 词法分析器生成工具Lex

1. Lex使用

   1. 用Lex语言写一个输入文件，描述要生成的词法分析器
   2. Lex编译器将lex文件转换成C语言程序
   3. 编译C程序,即得词法分析器
   4. <img src="./编译原理.assets/image-20240319223210269.png" alt="image-20240319223210269" style="zoom:50%;" /> 

2. Lex程序结构

   - ```c
     declarations           //声明
     %%
     translation rules      //转换规则
     %%
     auxiliary procedures  //辅助过程
     ```

   - ```c
     // 声明(定义)
     delim		[  \t\n]       // 定义空白字符
     ws	 	{delim}+         // 匹配一个或多个空白字符
     letter 		[A-Za-z]        // 定义字母
     digit 		[0-9]           // 定义数字
     id 		{letter} ({letter} | {digit})*    // 定义标识符
     number 	{digit}+(\.{digit}+)?(E[+-]?{digit}+)?   // 定义数字
     
     %%
     // 规则
     {ws}     	{ }            // 忽略空白字符
     if			{return(IF);}  // 匹配关键字"if"
     then		{return(THEN);}  // 匹配关键字"then"
     else		{return(ELSE);}  // 匹配关键字"else"
     {id}		{yylval=(int) installID( ); return(ID);}  // 匹配标识符
     {number}	{yylval=(int) installNum( ); return(NUMBER);}  // 匹配数字
     “<”			{yylval=LT; return(RELOP);}  // 匹配"<"
     “<=”		{yylval=LE; return(RELOP);}  // 匹配"<="
     “=”			{yylval=EQ; return(RELOP);}  // 匹配"="
     “< >”		{yylval = NE; return(RELOP);}  // 匹配"< >"
     “>”			{yylval = GT; return(RELOP);}  // 匹配">"
     “>=”		{yylval = GE; return(RELOP);}  // 匹配">="
     
     %%
     // 用户子程序
     int installID( ){  }  // 安装标识符
     int installNum( ) {  }  // 安装数字
     int num_lines = 0, num_chars = 0;  // 初始化行数和字符数
     
     %%
     \n    {++num_lines; ++num_chars;}  // 统计换行符
     .      {++num_chars;}  // 统计其他字符
     %%
     main( argc, argv )
     int argc; char **argv;
     {  
     	++argv, --argc;  // 跳过程序名
     	if ( argc > 0 )      
     		yyin = fopen( argv[0], "r" );  // 打开文件
      	else  
      		yyin = stdin;  // 默认输入为标准输入
      	yylex(  );  // 调用词法分析器
      	printf( "# of lines = %d, # of chars = %d\n", num_lines,  num_chars );  // 输出行数和字符数  
     }
     ```

3. Lex冲突解决
   - 当输入的多个前缀与多个模式匹配时，使用如下优先原则选择正确的词素：
     1. 匹配最长串的规则优先
     2. 长度相同时，在前的规则优先 (这样可以实现优先级)



## 3.4 有穷自动机

==有穷自动机== ( Finite Automata，FA )由两位神经物理学家MeCuloch和Pitts于1948年首先提出，是对一类处理系统建立的数学模型

- 这类系统具有一系列离散的输入输出信息和有穷数目的内部状态（状态：概括了对过去输入信息处理的状况）
- 系统只需要根据当前所处的状态和当前的输入信息就可以决定系统的后继行为（下一状态）。
  每当系统处理了当前的输入后，系统的内部状态也将发生改变



### 3.4.1 FA的表示

1. ==状态转换图== (Transition Graph)
   - **结点**：FA的状态
   - **初始状态**（开始状态）：只有一个，由start箭头指向
   - **终止状态**（接收状态）：可以有多个，用双圈表示
   - **带标记的有向边**：如果对于**输入a**，存在一个从状态p到状态q的转换，就在p、q之间画一条有向边，并标记上a
2. ==状态转换矩阵（表）==：描述各个状态下，对应于各个输入的状态迁移。



### 3.4.2 FA的分类

1. 确定的FA(Deterministic finite automata, **DFA**)
2. 不确定的FA(Nondeterministic finite automata, **NFA**)

#### DFA

**DFA是NFA的一个特例**

1. 对状态转换图的形式化
2. **没有输入ε**之上的转换动作
   - 一个空边会导致输出不确定
3. 对每个状态s和每个输入符号a，有且仅有一条标号为a的边离开



DFA是一个五元组，$M = ( S，Σ ，δ，s_0，F )$

- S：有穷状态集
- Σ：输入字母表，即输入符号集合。假设ε不是 Σ中的元素
- δ：状态转换函数，将S×Σ映射到S的单值部分映射。$\forall s∈S, a∈Σ, δ(s,a)$表示从状态s出发，沿着标记为a的边所能到达的状态。
- s0：开始状态 (或初始状态)，s0∈ S
- F：接收状态（或终止状态）集合，F⊆ S



#### NFA

NFA是一个五元组，$M = ( S，Σ ，δ，s_0，F )$

- S：有穷状态集
- Σ：输入符号集合，即输入字母表。假设ε 不是Σ中的元素
- δ：将S×Σ映射到$\color{red}2^S$的部分映射。$\forall s∈S, a∈Σ\cup\{\varepsilon\}, δ(s,a)$表示从状态s出发，沿着标记为a的边所能到达的状态集合
  - NFA是多值映射
- s0：开始状态 (或初始状态)，s0∈ S
- F：接收状态（或终止状态）集合，F⊆ S



#### FA对输入字符的接受

**定义**

1. 给定输入串x，如果存在一个对应于串x的从初始状态到某个终止状态的转换序列，则称串x被该FA==接受==
   1. 路径中的ε标号将被忽略
2. 由一个有穷自动机M接收的**所有串构成的集合**称为是该FA定义（或接收）的==语言==，记为L(M )

**匹配规则: 最长匹配**

1. 当输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配
2. 在到达某个终态之后，只要输入带上还有符号，FA就继续前进，以便寻找尽可能长的匹配
   - <img src="./编译原理.assets/image-20240322161257963.png" alt="image-20240322161257963" style="zoom:50%;" /> 
   - 如上图, 如果不使用最长匹配, `<=`会被识别为`<`和`=`



### 3.4.3 DFA&NFA的构建

#### DFA和NFA的等价性

1. ==等价FA==：对于任何两个有限自动机M和M'，若L(M)=L(M')，则称M和M'等价
   - 对任何非确定的有穷自动机N ，存在定义同一语言的确定的有穷自动机D
   - 对任何确定的有穷自动机D ，存在定义同一语言的非确定的有穷自动机N
   - 即: **DFA与NFA描述能力相同**！

2. 例: 
   <img src="./编译原理.assets/image-20240322162148194.png" alt="image-20240322162148194" style="zoom:50%;" />

#### 正则→FA

<img src="./编译原理.assets/image-20240322162517108.png" alt="image-20240322162517108" style="zoom:33%;" />

正则表达式以符号序列的形式非常直观的描述单词的构成，但是构造分析器时真正实现或模拟的是DFA。

直接由RE构造DFA是非常困难的，经常**通过NFA实现**。

#### 正则→NFA

1. 正则式ε对应 NFA <img src="./编译原理.assets/image-20240322162631502.png" alt="image-20240322162631502" style="zoom: 25%;" />
2. 正则式$a\in \Sigma$, 对应NFA <img src="./编译原理.assets/image-20240322162642028.png" alt="image-20240322162642028" style="zoom:25%;" /> 
   - **正则转换为NFA图的边**, 而不是节点(状态)
3. 若s,t是正则式, N(s)和N(t)是对应的NFA，则`s|t`对应之NFA为:<img src="./编译原理.assets/image-20240322162826985.png" alt="image-20240322162826985" style="zoom:25%;" /> 
4. 若s, t为正则式，N(s)和N(t)是对应的NFA，则`st`对应之NFA为: <img src="./编译原理.assets/image-20240322162856715.png" alt="image-20240322162856715" style="zoom: 25%;" /> 
   - 将s的结束状态和t的开始状态重合起来
5. 如果s是正则式, N(s)为对应NFA,  则`s*`对应之NFA为: <img src="./编译原理.assets/image-20240322163153908.png" alt="image-20240322163153908" style="zoom:25%;" /> 
   - 下面的空边: 匹配０次
     上面的空边: 匹配多次





#### NFA→DFA 子集构造算法

> 消除二义性?

**计算量:** 

1. ε-closure(s)  : $s \in S$      ==状态s的ε闭包==
   - 从状态s出发，仅通过ε边就能达到的状态集合 
2. ε-closure(T) :$ T \sube S $   ==状态集T的ε闭包==
   - 从状态集I中任一状态出发，仅通过ε边就能达到的状态集
3. move(T,a): $T \sube S,  a\in \Sigma $  ==转移函数==
   - 对于状态集T，在输入a时，可以到达的状态集**(不考虑ε边)**



**例**

例3-22 将下面的NFA转换成DFA

<img src="./编译原理.assets/image-20240322171717590.png" alt="image-20240322171717590" style="zoom:50%;" />

| I                          | Ia                   | Ib                     |
| -------------------------- | -------------------- | ---------------------- |
| {**0**,1,7,2,4} (〇)       | {**3,8**, 6,1,7,2,4} | {**5**,6,1,7,2,4}      |
| {**3,8**,6,1,7,2,4} (①)    | {**3,8**, …} (同①)   | {**5, 9**, 6,1,7,2,4}  |
| {**5**,6,1,7,2,4} (②)      | {**3,8**, …} (同①)   | {**5**, …}             |
| {**5, 9**, 6,1,7,2,4} (③)  | {**3,8**, …} (同①)   | {**10, 5**, 6,1,7,2,4} |
| {**10, 5**, 6,1,7,2,4} (④) | {**3,8**, …} (同①)   | {**5**, …}             |

- 技巧 找a边和b边, 看I中有哪些边的前驱节点

简化结果

| I         | a    | b    |
| --------- | ---- | ---- |
| 0         | 1    | 2    |
| 1         | 1    | 3    |
| 2         | 1    | 2    |
| 3         | 1    | 4    |
| 4 $\cdot$ | 1    | 2    |







### 3.4.4 等价相关概念

自动机的==等价==：可以存在多个识别同一语言的DFA，这些DFA等价。

==同构==：如果仅需变换状态的名字就可以将一个DFA变成另一个，则这两个DFA同构。

两个==状态的等价==：同时是或不是**接受状态**，且对任意的输入，总是转向同一状态或等价状态

最少状态数的DFA：合并等价状态。

串x**可区分**状态s和t：分别从s和t出发，沿串x到达的两个状态中，只有一个是接受状态。

### 3.4.5 最小化DFA

**基本思想**: 把M的状态集划分为一些不相交的子集，使得任何两个不同子集的状态是可区别的而同一子集的任何两个状态是等价的。最后，让每个子集选出一个代表，同时消去其他状态

#### 划分过程

**工作原理**：将状态集分划成多个组，每个组中的各个状态相互不可区分。然后，将每个组中的状态合并成一个状态。

1. 将状态集划分成两组：终结状态集 F 和 非终结状态集S - F.

2. **(循环直到不需要继续细分)** 
    考察当前划分中的每一组G：
  - 如果有必要，将G划分成若干子组，使各子组中的任意两个状态s 和 t 对于给定输入均转向划分中的同一组；并更新划分
3. 每组状态用一个状态代表，原DFA中所有由该组中状态发出的边或指向该组中某状态的边，都要与该代表状态关联。	

```mermaid
graph LR
0((S))
9((9))

0--0-->9
```





# 第4章 语法分析

## 4.3 自顶向下分析

> 语法分析：给定文法G和句子s，回答s是否能从G推导出来？

### 4.3.1 自顶向下分析的基本思想

==自顶向下分析==基本思想：从分析树的顶部（根节点）向底部（叶节点）方向构造分析树。即从文法的开始符号S出发推导出词串s的过程。

- 总是选择每个句型的**最左**非终结符进行替换 (最左推导)

- 根据输入流中的下一个终结符，选择最左非终结符的一个候选式

- > 例: <img src="./编译原理.assets/image-20240409170559722.png" alt="image-20240409170559722" style="zoom:50%;" />



### 4.3.2 自顶向下分析面临的问题

#### ①无限循环问题 (左递归)

> 例: 
>
> <img src="./编译原理.assets/image-20240409170658638.png" alt="image-20240409170658638" style="zoom:50%;" /> 
>
> - 对于终结符id, E不断选择E+T

对于我们使用的最左推导, 产生这个无限循环的原因即为左递归

- 如果一个文法中有一个非终结符A使得对某个串α存在一个推导$A\Rightarrow^+Aα$ ，那么这个文法就是==左递归==的
- 含有$A→Aα$形式产生式的文法称为是==直接左递归==的(immediate left recursive)
- 经过两步或两步以上推导产生的左递归称为是==间接左递归==的

##### 直接左递归的消除

处理策略：将直接左递归转化为直接右递归

- 将文法：$A\rightarrow A \alpha | \beta  (α≠ ε, β不以A开头)$
  转化为:   $A\rightarrow \beta A’\\ A’\rightarrow \alpha A’ | ε$ 
- 一般形式: 
  - $$\begin{gathered}
    A\to A\alpha_1|A\alpha_2|\ldots|A\alpha_n|\beta_1|\beta_2|\ldots|\beta_m \\
    (\alpha_i\neq\varepsilon,\beta_j\text{不以}A\text{开头}) \\
     \Downarrow \\
    A\to\beta_1A^{\prime}\mid\beta_2A^{\prime}\mid...\mid\beta_mA^{\prime} \\
    A'\to\alpha_1A'\mid\alpha_2A'\mid...\mid\alpha_nA'\mid\varepsilon  
    \end{gathered}$$ 
  - **消除的代价**: 产生了非终结符(A’)和$\varepsilon  $产生式

##### 间接左递归的消除

==间接左递归==：由多步推导带来的左递归
例如: <img src="./编译原理.assets/image-20240409171740909.png" alt="image-20240409171740909" style="zoom: 33%;" /> 

**间接左递归消除算法**
$$
\begin{align}
&按照某个顺序将非终结符号排序为A_1，A_2，… ，A_n\\
&for ( 从1到n的每个i ) \{\\
&\qquad for (从1到i-1的每个i ) \{\\
&\qquad\qquad 消除由A_j导致的左递归：即向每个形如A_i → A_jγ的产生式\\
&\qquad\qquad代入所有A_j为头的规则。得 A_i → δ1 γ∣δ2 γ∣…∣δk γ ，\\
&\qquad\qquad \quad其中A_j  → δ1∣δ2∣… ∣δk ，是所有的A_j产生式 \\
&\qquad\qquad    \}\\
&\qquad     消除A_i 产生式之间的直接左递归\\
 \}
 \end{align}
$$




### 递归下降的语法分析

### 4.3.4 预测分析

预测分析是递归下降分析技术的一个特例
在每一步推导过程中，通过在输入中向前看固定个数（通常是一个）符号来选择正确的A-产生式。为保证分析的确定性，选出的候选式必须是唯一的。
预测分析不需要回溯，是一种确定的自顶向下分析方法
可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法有时也称为==LL(k) 文法类== 

#### ①串首终结符

==串首终结符== ：串首第一个终结符，简称首终结符

**串α的首终结符集FIRST(α)**：可以从α推导出的所有首终结符构成的集合。

- 对于$\forall α∈(VT∪V N)+,  FIRST(α)=\{ a | α \Rightarrow ^* aβ，a∈ VT，β∈(V T∪ V N)*\}；$
- 如果 $α \Rightarrow ^* ε，那么 ε∈FIRST(α)$ (α =>* ε 表示串 α 可以经过一系列（可能是零个或多个）推导步骤最终被推导出空串ε)

如果非终结符A的所有候选式的首终结符集两两不相交，当要求A匹配输入串时，A就能根据当前输入符号a，选择唯一的正确的候选式。该候选式就是那个串首终结符集中包含a的α

#### ②计算文法符号X的FIRST(X )

反复执行以下步骤，直至无法加入新的终结符或ε
  1. 若 X 是终结符，则FIRST(X) = X.
  2. 若X是非终结符，且$ X\rightarrow Y_1Y_2…Y_k∈P(k≥1)$，则将 $FIRST(Y_1Y_2…Y_k) $加入到 FIRST(X); 
  3. 若$X \Rightarrow ε ∈P$，则将 ε 加入到 FIRST(X)

#### ③计算串$X_1X_2…X_n$的$FIRST(X_1X_2…X_n)$

1. 将FIRST(X1)中所有终结符加入 $FIRST(X_1X_2…X_n) $
2. for(i=1;i<n-1;i++)
    若$ε∈FIRST(X_i)$，将$FIRST(X_{i+1})$中所有终结符加入$FIRST(X_1X_2…X_n)$ ， 否则break; 
3. 如果对$∀i, ε∈FIRST(X_i)$成立, 则将 ε 加入 $FIRST(X_1X_2…X_n) $
   - 所有$X_i$都有$\varepsilon$

#### ④什么时候使用$\varepsilon$产生式

如果当前某**非终结符A**与当前**输入符a**不匹配时，若存在A→ε，可以通过检查**a是否可以出现在A的后面**，来决定是否使用产生式 A→ε

- 若文法中无 A→ε ，则应报错

- 判断a是否可以出现在A的后面: 使用FOLLOW(A)

#### ⑤非终结符的后继符号集

非终结符A的==后继符号集FOLLOW(A)==：可能在某些句型中紧跟在A右边的终结符号的集合。

- $FOLLOW(A)=\{a| S \Rightarrow^* αAaβ, a∈V_T，α,β∈(V_T∪V_N)^*\}$

- 如果A是某个句型的的最右符号，则将结束符“`$`”添加到FOLLOW(A)中

#### ⑥计算非终结符A的FOLLOW(A)

FOLLOW(A)：可能在某个句型中紧跟在A后边的终结符a的集合

$FOLLOW(A)=\{a| S \Rightarrow^* αAaβ, a∈V_T，α,β∈(V_T∪V_N)^*\}$

如果A是某个句型的的最右符号，则将结束符“$”添加到FOLLOW(A)中

#### ⑦计算所有非终结符的FOLLOW集

反复执行以下规则,直到无法加入新的终结符和`$`
1. 如果S是开始符, 将`$`加入FOLLOW(S), 这里`$`是输入结束标记.

2. 如果存在一个产生式$ A \rightarrow αBβ$, 则将 FIRST(β) 中的终结符加入 FOLLOW(B).

3. 如果存在:

  1. 产生式 $A\rightarrow aB$, 或者
  2. 产生式$A\rightarrowαBβ$, 且 ε∈FIRST(β) 

  - 则将FOLLOW (A) 加入 FOLLOW (B) .
