

## 一. 基础

### 1.1 基本格式

```assembly
.date


...
;use to set date用来设定数据
;like the early c,date only allow to be signed on the front of file像早期的c语言一样，数据只能在最前面被定义
--------------------------------------------
.code
main PROC
...

main ENDP
end main
;file ignore words after"end main"文件忽略在end main后面的所有语句
;must include "main PROC"代码段必须使用main PROC（就像c语言要有主函数一样）
--------------------------------------------
.stack(可以不标)
;系统自动生成

```

### 1.2 主要寄存器



1. 通用寄存器

| 寄存器名称 | 中英文含义                                | 作用                                                         |
| ---------- | ----------------------------------------- | ------------------------------------------------------------ |
| EAX        | 累加器 Accumulator                        | (针对操作数和结果数据的)累加器，一般用于运算，另外还多用于函数返回值中，用于保存返回值 |
| EBX        | 基址寄存器 Base Address Register          | (DS段中的数据指针)基址寄存器, 常用于存放存储器地址, 便于变量 |
| ECX        | 计数器 Counter                            | (字符串和循环操作的)计数器，如在循环命令LOOP中，ecx用来循环计数，每执行一次loop，ecx减1 |
| EDX        | 源变址寄存器                              | （I/O指针）计数器, 乘除指令中用作辅助累加器                  |
| ESI        | 源变址寄存器 Source Index Register        | （字符串操作源指针）源变址寄存器                             |
| EDI        | 目的变址寄存器 Destination Index Register | （字符串操作目标指针）目的变址寄存器，EDI和ESI多与特定指令，如LODS/STOS/REP/MOVS等一起使用，主要用于内存的复制。 |
|            |                                           |                                                              |
| EBP        | 基址指针寄存器 Base Pointer Register      | （SS段中栈内数据指针）扩展基址指针寄存器，表示栈区域的基地址<br>在函数被调用时保存ESP的值，函数返回时再把值重新返回给ESP，保证栈不会崩溃，这称为<font color='#66ccff'>栈帧技术</font> |
| ESP        | 堆栈指针寄存器 Stack Pointer Register     | （SS段中栈指针）栈指针寄存器，指示栈区域的栈顶地址，PUSH/POP/CALL/RET等指令可以直接用来操作ESP |

2. 指令指针寄存器 <font color='#66ccff'>EIP</font> 
   - 32位指令指针寄存器(EIP)存放指令指针，即当前代码段中将被执行的下一条指令的线性地址偏移
   - 程序运行时，CPU根据CS段寄存器和EIP寄存器中的地址偏移读取下一条指令，将指令传送到指令缓冲区，并将EIP寄存器的值自增，增大的大小即被读取指令的字节数。
   - EIP寄存器的值一般不能直接修改，EIP寄存器的更改有两种途径：一是通过特殊的跳转和调用/返回指令JMP、Jcc、CALL、RET等；二是通过中断或异常进行修改。
3. 标志寄存器 <font color='#66ccff'>EFlAGS</font>
   - IA-32中标志寄存器的名称为EFLAGS，其大小为4个字节(32位)，由原来的16位FLAGS寄存器**扩展**而来。
     EFLAGS寄存器的每位都有意义，每位的值或为1或为0，代表On/Off或True/False。
     其中有些位由系统直接设定，有些位则根据程序命令的执行结果设置。
   - 32位的EFLAGS寄存器用于存储算数操作符状态或其他执行状态。该寄存器中的各个位表示不同的标识，包括一组状态标识、一个控制标识和一组系统标识。EFLAGS寄存器中的标识主要用于实现条件分支。
     其中,与程序调试相关的状态标识包括:零标识(ZF),溢出标识(OF),进位标识(CF)和符号标识(SF)。各标识的具体含义如下:
     1. 零标识(ZF)。若算数或逻辑运算结果为0,则ZF值为1,否则ZF值为0。
     2. 溢出标识(OF)。有符号整数溢出时,OF置为1;最高有效位(MSB)改变时,OF置为1。
     3. 进位标识(CF)。无符号整数溢出时,CF置为1。
     4. 符号标识(SF)。等于运算结果的最高位(即有符号整数的符号位);0表示正数, 1表示负数。
     5. 方向标识(DF)。另一个需要注意的标识是控制标识(DF),该标识位为方向标识,用于控制串处理指令处理信息的方向。当DF为1时,每次操作后使变址寄存器ESI和EDI减小,这样就使串处理从高地址向低地址方向处理;当DF为0时,处理方向相反。DF标识由STD指令置位,由CLD指令清除。
     6. 陷阱标识(TF)和中断允许标识(IF)。它们是与中断和异常相关的标识位。如果TF标识位置为1,CPU将在执行完每条指令后产生单步中断,调试器使用该特性在调试程序时进行单步执行,该标识位还可用于检查调试器是否正常运行如果IF位置位,则CPU在收到中断请求后,应该对中断请求进行响应处理。
   - EFLAGS寄存器中的标识位及其功能：<img src="media/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBASGFyZHdvcmtpbmc2NjY=,size_16,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"  /> 

### 1.3 函数

1. 和c语言的函数类似，但是汇编的函数有以下要求

   1. 不能进行传参

   2. 无返回参数

2. 定义函数的格式

   ```assembly
   functionname PROC
   	.....
   	ret;一定要有
   functionname ENDP
   ```

   - 可以看出在基本格式中的code段的main也是函数

3. 函数的调用

   ```assembly
   CALL fuctionname
   ```

4. 函数与栈的关系：在用call指令的时候，将call所在语句的地址压入栈，遇到ret语句时候，取回地址跳回原位继续向下执行
   - `CALL fname` ↔ ① `push next` ②`jmp fname` 



## 二. 常用指令

1. 

### 运算符号

~~没学会下次再写~~ 



### 注释 `；`

相当于c语言的/ 用来表示后面的内容不编译，忽视

```assembly
xxxxx;后面随便写点啥都行
```



### 标号符

标号是程序的目标标志,总是和某地址相联系,供转移或循环指令控制转移使用.

```assembly
L0:xxxxxx

......

L1:xxxxxx
```

可以联想为c语言的goto语句来使用（虽然c的goto用的不多XD）

### 数据定义伪指令

通过数据定义语句可以为数据项分配存储单元，并设置初值。代表数据项的标识符称为变量名。

| 指令 |                             意义                             |
| ---- | :----------------------------------------------------------: |
| DB   | 单字节类型，占用**8位**或**1个字节**的数据，可以存储无符号整数、字符或其他数据 |
| DW   | 双字节类型, 占用**16位**或**2个字节**的数据，可以存储无符号整数、地址或其他数据 |
| DD   | 双字类型, 占用**32位**或**4个字节**的数据，可以存储无符号整数、地址或其他数据 |
| DQ   | 四字类型, 占用**64位**或**8个字节**的数据，可以存储无符号整数、地址或其他数据。 |
| DT   | 十字节型, 占用**80位**或**10个字节**的数据，可以存储实数或其他数据 |
| DS   |    由多个连续的字节组成的一组数据，可以存储文本或其他数据    |

#### 数值表达式

表达式结果是确定的数值，用于初始化内存单元

```assembly
date  dd 2;定义数字林子青
```

#### ?数据项

若定义的变量处置不确定可以用“？”表示，这是分配一个与类型匹配的存储单元，用于保留内存单元

```
date1 dd ?;定义未知变量
```

#### 字符串

以ASCII码值得形式存放在存储区中，每个字符占据一个存储单元

```
date2 dd "ac";定义未知变量
```

#### 重复定义

用n DUP (表达式)与数据定义伪指令搭配使用
dup可以嵌套使用

```
date3 dd 10 dup (2);定义十个2
date3 dd 10 dup (2，dup (?));分配20个空间给date3
```

### mov

mov A,B。将B的值传给A，B可以是一个数值，也可以用offset 来取相对地址

```
mov eax,b;将b的值移动进eax中
move esi,offset arr;将arr的地址移入esi中 
```

- 

### cmp

```
cmp A,B
```

对A,B的值进行比较，相当于是一个隐藏减法，不改变任何的值
底层原理是设定一个flag=A-B，一般与后续的条件一起使用
只能比较整数，字母值，不能比较小数

### jmp

无跳转跳转，类比于c的(while 1)多用于进行循环结构

```
	jmp L0
L0:
	...
```

### 条件转移


对于有符号数，使用有符号数的条件转移判断式，对于无条件数使用无符号数的条件转移判断式，都是jump+if+xxx的缩写，很好记

#### 无符号数

> b--below  a--above  e--equal  n--not

- ja 大于跳转
- jae 大等于跳转
- jb 小于跳转
- jbe 小等于跳转
- je 等于跳转
- jna 不大于跳转
- jne不等于跳转
- jnb不小于跳转



#### 有符号数

> l--less  g--greater  e--equal  n--not

- jg 大于跳转
- jge 大等于跳转
- jl 小于跳转
- jle 小等于跳转
- je 等于跳转
- jne,jng,jnl......

```assembly
	cmp a,b ; flag=a-b
	jge L0 ; flag>=0时，jump到L0
	...
L0:
	...
```

## 栈

~~没教完~~

 



# 第四章 指令系统

## 4.1 数据传送指令

1. 实现: 存储器↔寄存器↔I/O

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230310160408560.png" alt="image-20230310160408560" style="zoom:50%;" /> 

2. 四种传送指令

   - 通用数据传送
   - 目标地址传送
   - 标志传送
   - 输入输出

### 4.1.1 通用数据传送指令

#### MOV dest，src

1. 传送的是字节、字或双字

   具体来说可实现：

   ```assembly
   MOV mem/reg1，mem/reg2
   MOV reg，data ;立即数送寄存器
   MOV mem，data ;立即数送存储单元
   MOV segreg，mem/reg ;存储单元/寄存器送段寄存器
   MOV mem/reg，segreg ;段寄存器送存储元/寄存器
   ```

   - 注意 : 指令中两操作数中至少有一个为寄存器

     ```assembly
     MOV CL，DL
     MOV AX，BX
     MOV [ESI]，CX
     MOV CL，[EBX+5]
     MOV EAX,DWORD PTR [ESI]
     ```

     - 存储器←存储器：

       ```assembly
       MOV EAX，MEM1
       MOV MEM2，EAX
       ```

       需要一个寄存器作为中介

   - `MOV EAX, [EBX+ECX*4]`
     把DS段中有效地址为：`(EBX)＋(ECX)*4 `存储单元的**内容**送给 EAX寄存器

2. MOV指令使用规则：
   1. EIP不能作目的寄存器
   2. 不允许`mem←mem` (需要用寄存器作为中转)
   3. 不允许`segreg←segreg` 
      - 因为`mov segreg, segreg` 只是把一个段寄存器的值复制到另一个段寄存器，而不改变内存中的内容，所以它没有实际的作用
   4. 目的操作数不允许是立即数，也不允许是CS寄存器
   5. 不允许`segreg←立即数` 
      - mov 指令的规则
   6. 源操作数与目的操作数类型要一致

#### MOVSX带符号扩展传送指令

1. 格式：MOVSX dest，src；

2. 操作：（dest）←符号扩展（src）

   - 两种格式：

     ```assembly
     MOVSX reg1, reg2
     MOVSX reg, mem
     ```

3. 注意：源操作数可以是8位或16位，而目的操作数必须是16或32位。



### 2.1.4 PUSH入栈指令

1. 格式：`PUSH SRC`

2. 执行操作：
   (ESP) ←(ESP)-4
   ((ESP)+3, (ESP)+2, (ESP)+1,(ESP)) ←(SRC)

3. 几种用法：

   ```assembly
   PUSH reg ; 寄存器
   PUSH mem ; 内存变量
   PUSH data ; 8086不允许使用立即数寻址方式
   ```

### 2.1.5 POP 出栈指令

1. 格式 `POP DST`

2. 执行操作 : 

   (DST) ←((ESP)+3, (ESP)+2, (ESP)+1,(ESP))

   (ESP) ←(ESP)+4

3. 几种用法

   ```assembly
   POP reg ; 寄存器
   POP mem ; 内存变量
   ```



### 2.1.7 XCHG交换指令

格式：XCHG reg，mem/reg
操作：交换两操作数的内容。
要求：
- 两操作数中必须有一个在寄存器中；
- 操作数不能为段寄存器和立即数；
- 源和目地操作数类型要一致。
- 该指令允许除立即数以外的任何寻址方式。
举例： XCHG BX, [EBP+ESI] ; (BX) (EA)
XCHG AL, BH ; (AL) (BH)


### 地址传送指令

共有六种:

1. 格式：

   ```assembly
   LEA reg, mem ; 有效地址送寄存器指令, 相当于 mov reg, offset mem
   ```

2. 下面五个是指针送寄存器和段寄存器指令

   ```assembly
   LDS reg, mem32; DS: reg←(mem开始的四个内存单元)
   
   LES reg, mem32; ES: reg←(mem开始的四个内存单元)
   
   LFS reg, mem32; FS:reg←(mem开始的四个内存单元)
   
   LGS reg, mem32; GS:reg←(mem开始的四个内存单元)
   
   LSS reg, mem32; SS:reg←(mem开始的四个内存单元)
   ```

   

## 1 算术运算指令

- 两种类型数据:
  - 无符号数
  - 有符号数
- 加减法指令，无符号和有符号数采用同一套指令。
- 注意：
  - 操作数必须都是无符号数或都是有符号数。
  - 使用不同的标志位来检查无符号数和有符号数的运算结果是否溢出。

### 1.1 加法指令

#### 一. 不带进位的加法指令ADD

1. 格式：

   ```assembly
   ADD mem/reg, data
   ADD mem/reg1 ,mem/reg2 ;不能同时是存储器
   ```

2. 例：

   ```assembly
   ADD AL，30H
   ADD AX，[EBX+20H]
   ADD CX，SI
   ADD [EDI]，200H
   ```

   ADD指令对标志位（指状态标志）都有影响。

3. 例：`ADD DX, 0F0F0H`

   - 执行前：[DX]=4652H

     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230316155917861.png" alt="image-20230316155917861" style="zoom:33%;" /> 

   - 执行后：
     `(DX)＝3742H，ZF=0，SF=0，CF=1，OF=0`
     结果正确。

#### 二. 带进位的加法指令ADC

- ADC指令在形式上和功能上都有与ADD类似，只是相加时还要包括进位标志CF的内容，例如：

  ```assembly
  ADC AL，68H ;AL←(AL)+68H+(CF)
  ADC AX，CX ;AX←(AX)+(CX)+(CF)
  ```

- ADC指令主要用于多字节加法运算中



##### ADD/ADC对条件标志位(CF/OF/ZF/SF)的影响

- CF位表示无符号数相加的溢出。
- OF位表示带符号数相加的溢出。
  $$1 结果为负
  0 否则
  SF= 1 结果为0
  0 否则
  ZF=
  1 和的最高有效位有向高位的进位
  0 否则
  CF=
  1 两个操作数符号相同，而结果符号与之相反
  0 否则
  OF=

#### 三. 加1指令INC

1. 格式：INC reg/mem

2. 功能：类似于C语言中的++操作：对指定的操作数加1

3. 例： 

   ```assembly
   INC AL ；(AL) ← (AL)+1
   INC SI
   ```

4. 注：本指令不影响CF标志
   - 不影响循环

### 1.2 减法指令

#### 一. 不考虑借位的减法指令SUB

1. 格式： SUB dest, src

2. 执行操作: (dest)←(dest) - (src)

3. 注意：

   1. 源和目的操作数不能同时为存储器操作数
   2. 立即数不能作为目的操作数

4. 例：

   ```assembly
   SUB AL，60H
   SUB [EBX+20H]，DX
   SUB AX，CX
   ```

   

#### 二. 考虑借位的减法指令SBB

SBB指令主要用于多字节的减法。
格式： SBB dest, src
操作： (dest)←(dest)-(src)-(CF)
例：
SBB AX，CX
SBB [ESI]，DX

#### 三. 减1指令DEC

作用类似于C语言中的－－操作符。
格式：DEC opr
操作： (opr)←(opr)-1
指令例子：
DEC CL
DEC SI



### 1.4 除法指令

1. 无符号数除法指令： `DIV SRC`
2. 带符号数除法指令： `IDIV SRC`
3. 执行操作：
   - 字节操作
     -  (AL) ← (AX) / (SRC) 的商
     - (AH) ← (AX) / (SRC) 的余数
   - 字操作 
     - (AX) ← (DX, AX) / (SRC) 的商
     - (DX) ← (DX, AX) / (SRC) 的余数
   - 双字操作 
     - (EAX) ← (EDX, EAX) / (SRC) 的商
     - (EDX) ← (EDX, EAX) / (SRC) 的==余数==
     - 进行除法前要对EDX赋初值



## 逻辑运算指令

1. 逻辑非指令：NOT OPR (OPR不能为立即数)

   执行操作： (OPR) ← ¬ (OPR) (不影响标志位)

   - NOT不允许使用立即数，其他4条指令除非源操作数可以是立即数，至少有一个操作数必须存放在寄存器，另一个操作数可
     以是任何寻址方式。

2. 逻辑与指令：AND DST, SRC

   执行操作： (DST) ← (DST) ∧ (SRC)

3. 逻辑或指令：OR DST, SRC

   执行操作： (DST) ← (DST) ∨ (SRC)

4. 异或指令： XOR DST, SRC

   执行操作： (DST) ← (DST) ⊕ (SRC)

5. 测试指令： TEST OPR1, OPR2

   执行操作： (OPR1)  (OPR2)



## 移位指令

1. 逻辑左移 `SHL OPR, CNT`

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230316162306012.png" alt="image-20230316162306012" style="zoom:33%;" /> 

2. 逻辑右移 `SHR OPR, CNT` 

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230316162318210.png" alt="image-20230316162318210" style="zoom:33%;" /> 

3. 算术左移 `SAL OPR, CNT`

   - 同逻辑左移, 都是在末尾补0

4. 算术右移 `SAR OPR, CNT` 

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230316162338269.png" alt="image-20230316162338269" style="zoom:33%;" /> 

5. 循环左移 `ROL OPR, CNT` 

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230316163903861.png" alt="image-20230316163903861" style="zoom: 33%;" /> 

6. 循环右移 `ROR OPR, CNT` 

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230316163927711.png" alt="image-20230316163927711" style="zoom:33%;" /> 

7. 带进位循环左移 `RCL OPR, CNT` 

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230316163941167.png" alt="image-20230316163941167" style="zoom:33%;" /> 

8. 带进位循环右移 `RCR OPR, CNT` 

   <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230316163955804.png" alt="image-20230316163955804" style="zoom:33%;" /> 





## 串处理指令

- 串处理指令 : MOVS、 STOS、 LODS 、 CMPS、 SCAS
- 设置方向标志指令 : CLD、STD
- 串重复前缀 : REP、 REPE / REPZ、 REPNE / REPNZ



### MOVS 串传送指令

1. 四种格式
   - MOVS
   - MOVSB （字节）
   - MOVSW （字）
   - MOVSD （双字）
2. 例：MOVS ES: BYTE PTR [EDI], DS: [ESI]
3. ​	执行操作：
   1. ((EDI)) ← ((ESI))
   2. 字节操作：(ESI)←(ESI)±1, (EDI)←(EDI)±1
   3. 字操作： (ESI)←(ESI)±2, (EDI)←(EDI)±2
   4. 方向标志 DF=0 时用 + ，DF=1 时用 -

3. 执行 REP MOVS 之前，应先准备：

   1. 源串首地址（末地址）→ ESI

   2. 目的串首地址（末地址）→ EDI

   3. 串长度 → ECX

   4. 建立方向标志

      - CLD 使 DF=0

      - STD 使 DF=1

### STOS 存入串指令：

1. 格式：

   - STOS DST
   - STOSB （字节）
   - STOSW （字）
   - STOSD （双字）

2. 执行操作：

   - 字节操作：((EDI))←(AL), (EDI)←(EDI)±1
   - 字操作： ((EDI))←(AX), (EDI)←(EDI)±2
   - 双字操作： ((EDI))←(EAX), (EDI)←(EDI)±4

   - 不影响条件标志位

### LODS 从串取指令

格式：
LODS SRC
LODSB （字节）
LODSW （字）
LODSD （双字）
执行操作：
字节操作：(AL)←((ESI)), (ESI)←(ESI)±1
字操作： (AX)←((ESI)), (ESI)←(ESI)±2
注意:

* LODS 指令一般不与 REP 联用
* 源串一般在数据段中（允许使用段跨越前缀来修改），
目的串必须在附加段中
* 不影响条件标志位



### CMPS 串比较指令

1. 格式：
   - CMPS SRC, DST
   - CMPSB （字节）
   - CMPSW （字）
   - CMPSD （双字）
2. 执行操作：
  1) ((ESI)) - ((EDI))
     - 根据比较结果置条件标志位：相等 ZF=1; 不等 ZF=0
  2) 字节操作：(ESI)←(ESI)±1, (EDI)←(EDI)±1
     字操作： (ESI)←(ESI)±2, (EDI)←(EDI)±2



## 六、控制转移指令
• 无条件转移指令
JMP
• 条件转移指令
JZ / JNZ 、 JE / JNE、 JS / JNS、 JO / JNO、
JP / JNP、 JB / JNB、 JL / JNL、 JBE / JNBE、
JLE / JNLE、 JCXZ jecxz
• 循环指令
LOOP、LOOPZ / LOOPE、LOOPNZ / LOOPNE
• 子程序调用和返回指令
CALL、RET
• 中断与中断返回指令
INT、INTO、IRET

## 汇编器使用

1. 有时在cmp两个内存变量时, 报错会报成end main

# 一些模板

1. 函数模板

   - void
   
     ```assembly
     myFun PROC 	;; void myFun(int* arr, int n) input:<----入栈顺序
     			;; return:void
     ; [ebp+4]: 调用函数位置的地址
     ; [ebp+8]: arr
     ; [ebp+12]: n
     	push ebp ; 暂存栈底寄存器
     	mov	ebp, esp ; 修改栈底, 创建一个"栈帧"
     	pushad ; 存放所有寄存器
     	
     	... ; 代码段
     	
     	popad ; 恢复所有寄存器
     	pop	ebp ; 恢复栈底寄存器
     	ret	8 ; 返回原函数, 并pop8字节(去除栈中的arr和n)
     	;; 也就是 传入2个4字节参数, 此时就ret 2*4(8)
     myFun ENDP
     ```
   
   - 有返回值
   
     ```assembly
     myFun PROC 	;; myFun(int* arr, int n) input:<----入栈顺序
     			;; return:eax
     ; [ebp+4]: 调用函数位置的地址
     ; [ebp+8]: arr
     ; [ebp+12]: n
     	push ebp ; 暂存栈底寄存器
     	mov	ebp, esp ; 修改栈底, 创建一个"栈帧"
     	sub esp, 4 ; 为返回值预留4个字节
     	pushad ; 存放所有寄存器
     	
     	... ; 代码段
     	
     	mov [ebp-4], eax ; 暂存返回值
     	popad ; 恢复所有寄存器
     	mov eax, [ebp-4] ; 保存返回值到eax
     	add esp, 4 ; 去除预留个4字节
     	pop	ebp ; 恢复栈底寄存器
     	ret	8 ; 返回原函数, 并pop8字节(去除栈中的arr和n)
     	;; 也就是 传入2个4字节参数, 此时就ret 2*4(8)
     myFun ENDP
     ```
   
     

```yaml
#compose版本
version: "3"  
 

services:
  yj_blog:
#微服务镜像  
    image: yj_blog:1.0
    container_name: yj_blog
    ports:
      - "7777:7777"
#数据卷
    volumes:
      - /app/yj_blog:/data/yj_blog
    networks: 
      - blog_network
    depends_on: 
      - redis
      - mysql
      - nginx


  yj_admin:
#微服务镜像
    image: yj_admin:1.0
    container_name: yj_admin
    ports:
      - "8989:8989"
#数据卷
    volumes:
      - /app/yj_admin:/data/yj_admin
    networks:
      - blog_network
    depends_on:
      - redis
      - mysql
      - nginx
     
#redis服务
  redis:
    image: redis:6.0.8
    ports:
      - "6379:6379"
    volumes:
      - /app/redis/redis.conf:/etc/redis/redis.conf
      - /app/redis/data:/data
    networks: 
      - blog_network
    command: redis-server /etc/redis/redis.conf
 
 #mysql服务
  mysql:
    image: mysql:8.0.19
    environment:
      MYSQL_ROOT_PASSWORD: 'xu.123456'
      MYSQL_ALLOW_EMPTY_PASSWORD: 'no'
      MYSQL_DATABASE: 'yj_blog'
      MYSQL_USER: 'root'
      MYSQL_PASSWORD: 'xu.123456'
    ports:
       - "3306:3306"
    volumes:
       - /app/mysql/db:/var/lib/mysql
       - /app/mysql/conf/my.cnf:/etc/my.cnf
       - /app/mysql/init:/docker-entrypoint-initdb.d
    networks:
      - blog_network
    command: --default-authentication-plugin=mysql_native_password #解决外部无法访问

 #nginx服务
  nginx:
    image: nginx:1.18.0
    ports:
      - "80:80"
      - "8093:8093"
      - "8094:8094"
    volumes:
      - /app/nginx/html:/usr/share/nginx/html
      - /app/nginx/logs:/var/log/nginx
      - /app/nginx/conf:/etc/nginx
    networks:
      - blog_network
    

 
 #创建自定义网络
networks: 
   blog_network: 

```



