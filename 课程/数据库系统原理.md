# 第一章 绪论

## 1.1 数据库系统概述

1. 几个基本概念：数据、数据库、DBMS、DBS。
   - <font color=66ccff>数据(Data) </font>: 描述事物的符号记录
   - <font color=66ccff>数据库(Database, DB)</font> : 长期存储在计算机内有组织, 可共享的大量数据集合
   - <font color=66ccff>数据库管理系统(Database Mange System, DBMS) </font>: 和操作系统一样, 是计算机的基础软件, 主要功能包括
     1. 数据定义功能. DBMS提供数据定义语言(data definition language, DDL)对数据库中的数据对象的组成和结构进行定义
     2. 数据组织, 存储和管理功能.
     3. 数据操纵功能. 提供数据操纵语言(data manipulation language, DML), 进行增删改查
     4. 数据谷的事务管理和运行管理功能
     5. 数据库的建立和维护功能
     6. 其他功能, 包括DBMS与网络中其他软件系统的通信功能; 两个DBMS之间的数据转换功能; 异构数据库之间的互访互操作功能等
   - <font color=66ccff>数据库系统(Database System, DBS) </font>: 由数据库, DBMS(及其应用开发工具), 应用系统和数据库管理员(database administrator, DBA)组成的存储, 管理, 处理和维护数据的系统

2. 数据管理技术的产生和发展

   - | 对比项       | 人工管理阶段                         | 文件系统阶段             | 数据库系统阶段                                               |
     | ------------ | ------------------------------------ | ------------------------ | ------------------------------------------------------------ |
     | 应用领域     | 科学计算                             | 科学计算,数据管理        | 大规模数据管理                                               |
     | 主要硬件     | 无直接存取存储设备                   | 磁盘, 磁鼓               | 大容量磁盘, 磁盘阵列                                         |
     | 主要软件     | 没有操作系统, 没有管理数据的专门软件 | 有文件系统               | 有数据库管理系统                                             |
     | 数据处理方式 | 批处理                               | 联机实时处理, 批处理     | 联机实时处理, 分布处理, 批处理                               |
     | 数据管理者   | 人(程序员)                           | 文件系统                 | 数据库管理系统                                               |
     | 数据面向对象 | 某一应用程序                         | 某一应用                 | 现实世界(部门, 企业, 跨国组织等)                             |
     | 数据共享程度 | 不独立, 完全依赖应用                 | 独立性弱                 | 具有较强的物理独立性和一定的逻辑独立性                       |
     | 数据结构化   | 无结构                               | 记录内有结构, 整体无结构 | 整体结构化, 用数据模型描述                                   |
     | 数据控制能力 | 应用程序自己控制                     | 应用程序自己控制         | 由数据库管理系统提供数据安全性, 完整性, 并发控制和数据库恢复功能 |

3. 数据库系统的特点
   - 整体数据的结构化: 数据之间具有联系, 不仅要考虑某个应用的数据结构, 还要考虑整个组织的数据结构
   - 数据的共享性强, 冗余度低且易于扩充
   - 数据的独立性强: 数据改变时, 代码不用修改, 相互独立
     - 物理独立性: 数据的物理结构改变时, 应用程序不用改变
     - 逻辑独立性: 数据的逻辑结构改变时, 应用程序不用改变
   - 数据有数据库管理系统统一管理和控制
     - 数据库的安全性(security)保护
     - 数据库的完整性(integrity)检查
     - 数据库的并发性(concurrency)控制
     - 数据库的恢复

## 1.2 数据模型

1. 两类：概念模型<font color='orange'><E-R图></font>、逻辑模型<font color='orange'>(本书中的数据模型指的是逻辑上的数据模型)</font>和物理模型<font color='orange'>(DBMS实现)</font>
   - ![C29CFJQ5GGKG`ST`LWVHEBU](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/C29CFJQ5GGKG%60ST%60LWVHEBU.png)

2. 数据模型三要素

   - 概念模型：实体、联系、E-R图(Entity-Relationship model)

   - 逻辑模型：层次、网状、关系

### 1.2.1 概念模型-信息结构与E-R方法

1. 数据的三种范畴: 物理世界, 信息世界, 计算机

   - 现实世界的术语：事物、特征、事物集、标识特征。

     - 事物：客观存在并可以相互区分的事、物或抽象事件。

     - 特征：事物的某个性质/属性/方面。

     - 事物集：具有相同特征的一类事物的集合。

     - 标识特征：区分事物的特征**。**
   - 信息世界的术语：

     - 实体Entity：客观存在并可以相互区分的事物或抽象事件。//个体
     - 属性Attribute**：**实体所具有的某一特性
     - 码Key：唯一标识实体的属性或属性集
     - 域Domain：属性的取值范围。
     - 实体型：用实体名及其属性名集合来抽象和刻画同类实体。
     - 实体集：同一类型实体的集合。//实体
     - 联系Relationship**：**实体内部的联系和实体之间的联系**。**

   - 计算机世界的术语：记录、数据项/字段、文件、关键字。
     - 型和值：型表示定义/结构，值表示某个术语的具体的表现/值。

2. 两个实体之间的联系：

   （1）一对一联系：1:1

   （2）一对多联系：1:n

   （3）多对多联系：m:n

3. 如何表示？实体-联系方法(Entity-Relationship)

   - 实体-联系方法用于描述现实世界中的信息结构，描述结果称为E-R模型或概念模型。它是最高级的抽象，与具体的数据模型没有关系。现实世界中的语义在这里（指确定联系类型的种类）起了最关键的作用！

4. 图元素

   - 实体：用矩形框表示，并写上实体名。
   - 属性：用椭圆形表示，写上属性名，用边与相应的实体相连。
   - 联系：用菱形框表示，写上联系名，并用连线与有关的实体相连。

5. 联系

   - **1:1联系** 实体A中的个体与实体B中的个体存在一一对应关系。比如，厂长实体与工厂实体，如下所示。
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230901225904628.png" alt="image-20230901225904628" style="zoom:50%;" />

   - **1:n联系** 对于实体A中的一个个体，在实体B中可以有多个个体与之对应，但对于实体B中的一个个体，实体A中最多只有一个个体与之对应。比如，学校实体与学生实体。
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230901230006588.png" alt="image-20230901230006588" style="zoom:50%;" />

   - **m:n联系** 对于实体A中的一个个体，在实体B中可以有多个个体与之对应，反之亦然。比如，学生实体与课程实体。
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230901230035586.png" alt="image-20230901230035586" style="zoom:50%;" />

   - **两个以上的实体型之间**的联系：也可以有如上三种联系。

     比如，在考虑仓库、器件、供应商三个实体时，我们规定：每个仓库可以向多个供应商订购多种器件，每个供应商可以向多个仓库提供多种器件，每种器件可以由多个供应商供应，可以由多个仓库购买。这样，描述仓库、器件、供应商三个实体之间的E-R图如下所示。
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230901230836428.png" alt="image-20230901230836428" style="zoom:50%;" />

   - **单个实体型内**的联系：实体A中的两个个体之间也可以存在着联系。比如，在职工实体中，有领导者与被领导者，用E-R图表示为：
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230901230713778.png" alt="image-20230901230713778" style="zoom: 50%;" /> 
     当然，也可以考虑两个实体：职工、领导者。这样的设计与上述设计对今后数据库有很大的影响。

6. 标识属性加下划线。

   - 注意：*联系也有属性*。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230901231038043.png" alt="image-20230901231038043" style="zoom:50%;" /> 

7. 例

   - > 实体之间的联系主要取决于现实世界的管理方法，或者说，取决于语义，即同样两个实体，在不同的语义下，将有不同的联系类型。比如，对于仓库和器件两个实体：
     >
     > - 如果规定一个仓库只能存放一种器件，并且一种器件只能存放在一个仓库，这时仓库和器件之间的联系是一对一的
     > - 如果规定一个仓库可以存放多种器件，但是一种器件只能存放在一个仓库，这时仓库和器件之间的联系是一对多的
     > - 如果规定一个仓库可以存放多种器件，同时一种器件可以存放在多个仓库，这时仓库和器件之间的联系是多对多的

   - > 实体：
     >
     > - 仓库：属性有仓库号、面积、电话号码
     > - 零件：属性有零件号、名称、规格、单价、描述
     > - 供应商：属性有供应商号、姓名、地址、电话号码、帐号
     > - 项目：属性有项目号、预算、开工日期
     > - 职工：属性有职工号、姓名、年龄、职称
     >
     > 实体之间的联系如下：
     >
     > （1）一个仓库可以存放多种零件，一种零件可以存放在多个仓库，因此仓库和零件之间的联系是多对多的；用库存量表示某种零件在某个仓库中的数量。 
     >
     > （2）一个仓库有多个职工，一个职工只能在一个仓库工作，因此仓库和职工之间的联系是一对多的。
     >
     > （3）职工之间具有领导-被领导关系，因此职工实体型中具有一对多的联系。
     >
     > （4）供应商、项目和零件三者之间有多对多的联系。
     >
     > ![image-20230901231925067](https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230901231925067.png)

### 1.2.2 数据模型-数据逻辑模型

1. 数据模型三要素
   - 数据结构: 描述数据库的组成对象以及对象之间的联系。
     - 如 层次结构、网状结构、关系结构和面向对象结构。
   - 数据操作： 对数据库中各种对象允许执行的操作集合
     - 如关系模型的增删改查
   - 完整性约束(Integrity Constraints, IC): 规定给定的数据模型中数据及其联系所应满足的制约和依存规则，以保证数据的正确、有效和相容。
     - 对关系模型而言，有三种完整性约束：实体完整性、参照完整性和用户自定义完整性。
2. 传统的三种数据逻辑模型: 层次模型, 网状模型, 关系模型

#### 层次模型

- 用树形结构来表示实体以及实体之间的联系, 在层次模型中，结点表示实体，连线表示一对多的联系。
- 层次模型的特征/限制是：
  1. 有且仅有一个结点无父结点，这个结点即为树的根；
  2. 其他结点有且仅有一个父结点。
- <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230907155458573.png" alt="image-20230907155458573" style="zoom: 50%;" /> 
- 层次数据库管理系统的典型代表是：IMS(Information Management System)
  - 型和值: IMS中把构成层次结构的一组实体称作层次型，层次型中的每个实体称作片段，组成片段的最小数据单位是字段。
- 层次模型特点
  - 层次模型像一棵倒立的树。
  - 层次模型的一个基本的特点是：任何一个给定的记录值只有按其路径查看时，才能显出它的全部意义，没有一个子女记录值能够脱离**父结点记录值**而独立存在。
    <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230907180019520.png" alt="image-20230907180019520" style="zoom:50%;" />
  - 层次型数据库不支持多对多联系，可以考虑把有两个父结点的非层次结构转换成两个层次型。
- 层次模型的数据操纵：查询、插入、删除和更新。
- 层次模型的完整性约束条件：维持层次模型, 如插入时没有相应的双亲节点值就不能插入其子女结点值, 删除双亲节点值, 那么子女结点值也要删除
- 层次模型的存储结构：
  - 邻接法：P23
  - 链接法：P24
- 层次模型的优缺点：
  - 优点：数据结构简单、清晰;查询效率高；良好的完整性支持。
  - 缺点：多对多联系表示困难；一个结点有多个双亲时，表示比较困难；查询子女结点必须通过其双亲结点；层次命令趋于结构化。

#### 网状模型

- 用网络结构来表示实体之间联系的数据模型称为<font color='#66ccff'>网络数据模型</font>font>。
  网络模型的典型代表是CODASYL ——Conference On Data System Language.
- 在网络模型中，取消了层次模型中的两点限制，即允许一个结点可以有多个父结点。
  - 网络模型和层次模型在本质上是一样的，从逻辑上看它们都是用连线表示实体之间的联系，用结点表示实体；
    从物理上看它们都是用指针来实现两个文件之间的联系，只是在网络模型中连线更加复杂。
- 网状数据模型的存储结构：P27图1。25
- 网状模型的优缺点：
  - 优点：①结点之间可以有多种联系，因此能够更为直接地描述某些现实世界。②存取效率较高。
  - 缺点：①结构比较复杂；②相应的DDL、DML语言复杂；③记录之间联系是通过存取路径而实现，应用程序在访问数据时必须选择适当的存取路径。

#### 关系模型

- 关系模型Relational Data Model：用关系结构（二维表）来表示实体以及实体之间的联系。
- 关系数据库管理系统的典型代表是：Oracle、Sybase、DB2、SQL Server、InfoMix、Access…。

- lBasic Concepts：

  - 一个关系对应一张二维表；
  - 在关系模型中，二维表格中的每一行称作一个<font color='#66ccff'>元组(Tuple)</font>，它相当于一个记录值，每一列是一个属性，列可以命名，称为属性名。因此可以说，关系是元组的集合。如果表格中有n列，称该关系是n元关系。

  - 一些定义
    - <font color='#66ccff'>码</font>：表中的某个/些属性集，可以唯一地确定一个元组。
    - <font color='#66ccff'>域</font>：属性的取值范围。
    - <font color='#66ccff'>分量</font>：元组中的一个属性值。
    - <font color='#66ccff'>关系模式</font>：对关系的描述。一般表示为：关系名（属性1，属性2，……，属性n）
    - 关系数据模型的<font color='#66ccff'>固有约束</font>：关系的每一个分量必须是一个不可分的数据项目。

- 关系数据模型的存储结构：
- 关系数据模型的优缺点：
  - 优点：
    1. 有严格的数学概念//[集合论](# 正式定义)
    2. 关系模型的概念单一//？
    3. 存取路径对用户透明。//Transparent!
  - 缺点：查询效率比较低。//Query Optimization

## 1.3 数据库系统的结构

> 如何认识数据库系统的体系结构？
>
> - 从企业信息化建设的角度来看：DBS总体架构可以采用集中式和分布式两类，在集中式DBS中根据数据访问模式的不同又分为C/S和B/S两种体系结构；
> - 从信息管理系统的组成部分来看：DBS=DBMS+DB+DBA+Application+Specifications
> - 从计算机系统的角度来看：DBS将所有的数据划分为**三层模式**，相邻两层模式之间提供**映射**，见后面论述。

### 1.3.1 三层模式

数据库系统的三级模式结构：外模式、模式和内模式。相应地，有三层数据库。
<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230907221508135.png" alt="image-20230907221508135" style="zoom: 50%;" /> <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230907221516061.png" alt="image-20230907221516061" style="zoom: 67%;" />

- 定义**存储数据库结构**的模式称作<font color='#66ccff'>存储模式/内模式</font>；
  - 内模式是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。

- 定义**概念数据库结构**的模式称作<font color='#66ccff'>概念模式</font>，简称<font color='#66ccff'>模式</font>； <font color='orange'>(此处的概念模式指的是数据逻辑模型, 要与概念模型相区别)</font>
  - 模式实际上是数据库在逻辑级上的视图(window)。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，统一综合地考虑了所有用户的需求，并将这些需求有机地结合成一个逻辑整体。

- 定义**外部数据库结构**的模式称作<font color='#66ccff'>外部模式</font>，也称<font color='#66ccff'>子模式</font>；
  - 用户的数据视图


### 1.3.2 两种映象

> 在数据库的三级模式结构中，存在两种映像，外模式/模式映像，模式/内模式映像。

<font color='#66ccff'>外模式/模式映像</font>

- 定义了某个外模式与模式之间的对应关系。当模式改变时，由DBA对各个外模式 /模式的映像作相应的改变，可以使外模式保持不变。应用程序是依据外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性。
- <font color='#66ccff'>概念数据独立性(逻辑独立性)</font>: 
  - 外部文件/子文件：概念文件中与某个应用程序相关的部分字段。
  - 指当修改概念文件的结构时<font color='orange'>(数据逻辑结构改变)</font>，应用程序不用改变。

<font color="#66ccff">模式/内模式映像</font>

- 定义了数据全局逻辑结构与存储结构之间的对应关系。当数据库的存储结构改变了，由DBA对模式/内模式映像作相应修改，可以使模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性。

- <font color = #66ccff>存储数据独立性(物理独立性)</font>：存储文件的存储方法和存储结构<font color=orange>(物理存储)</font>改变，用户程序不用改变

  

## 1.4 数据库系统的组成

1. DBS的组成：数据库, DBMS(及其应用开发工具), 应用系统和数据库管理员(database administrator, DBA)组成

2. 数据库管理系统DBMS读取一条记录时所发生的一系列事件：
   1. 用户程序A向DBMS发出读一条记录的指令，这时用户程序要给出外部文件名和记录的关键字值；
   2. DBCS(数据库控制系统)分析所接到的指令，访问对应的外部模式；
   3. DBCS完成外部模式到概念模式的转换，决定访问哪个/些概念文件；
   4. 接着由DBSS(数据库存储系统)完成概念模式到存储模式的转换，并决定访问哪个/些存储文件；
   5. DBSS调用存取方法，通过操作系统将读取的记录送到系统缓冲区；
   6. 用户程序从系统缓冲区得到所需记录和DBMS返回的状态信息；
   7. 用户程序在工作区中使用所得到的记录。



## 第一章小测

一：选择题（3分）

1．物理数据独立性是指（**C**）。

   A．模式改变，外模式和应用程序不变；B．逻辑模式改变，内模式不变

   C．内模式改变，逻辑模式不变；     D．外模式改变，模式不变

2．数据库在磁盘上的基本组织形式是（ **B**）。

   A．DB   B．文件   C．二维表   D．系统目录

3．当关系有多个候选码时，则选择一个作为主码，但若主码为全码时应包含( **D** )。

   A．单个属性   B．两个属性   C．多个属性   D．全部属性

二：填空题（5分）

1、数据管理技术的发展，与 <u>计算机硬件 、 系统软件 和  应用</u> 有密切的联系。

2、对现实世界进行第一层抽象（最高级别的抽象）的模型，称为 <u>概念</u> 模型，对现实世界进行第二层抽象的模型，称为 <u>逻辑</u> 模型。

三：E-R图（6分）

设要建立一个企业数据库，该企业各部门有许多职员，但一个职员仅属于一个部门；每个职员可参加多项工程，每项工程可有多个职员；有若干供应商同时为各不同工程供应各种零件。试画出E-R图，自行适当给出各实体的属性2-3个。 

- 注意: 零件也是实体 供应商:零件(M:N)

四、简答题（6分）

1.数据逻辑模型三要素是什么？对于关系模型而言，其三要素是什么？

- **数据结构; 数据操纵; 完整性约束**
   **二维表; 增删改查; 实体完整性, 参照完整性, 用户定义完整性**

# 第二章 关系数据库

> History of Relational Database
>
> - CODASYL于1962年发表的“信息代数”一文 
>
> - E.F.Codd从1970年起发表了一系列的论文
>
> - 20世纪70年代末的实验系统System R和Ingres(UCB)
>
> - 从20世纪80年代逐步走向成熟,Oracle, Sybase…

## 2.1 关系数据结构及形式化定义

1. <font color='#66ccff'>关系</font>数据结构 (什么是关系)
   - 关系数据结构非常简单，在关系数据模型中，现实世界中的实体及实体与实体之间的联系均用关系来表示。从逻辑或用户的观点来看，关系就是**二维表**。 
2. 关系型数据库操作
   - 传统的集合运算 
     - 并（Union） 、交（Intersection） 、差（Difference） 
     - 广义笛卡尔积（Extended Cartesian Product） 
   - 专门的关系运算
     - 选择（Select） 、投影（Project） 、连接（Join）
     - 除（Divide）
   - 有关的数据操作 
     - 插入（Insert） 删除（Delete） 修改（Update） 
   - ==注意==: 
     - 关系是以集合的方式操作的，即操作的对象是元组的集合，操作的结果也是元组的集合。
       这和非关系模型的操作结果是一条记录有着重要区别。
3. 关系的操作方式
   - 关系的操作能力可以用代数方式和逻辑方式来表示: 
     - 代数方式是通过关系代数对关系的运算来表达查询要求的方式。典型代表是关系代数语言。
     - 逻辑方式是通过关系演算、用谓词表达对关系的查询要求的方式。典型代表是元组关系演算语言和域关系演算语言。 //DataLog语言：人工智能语言Prolog在数据库中的应用。
   - <font color='#66ccff'>关系数据库标准语言 SQL（Structured Query Language）</font>，它是一种介于关系代数和关系演算的语言，提供DDL（数据定义语言）、DML（数据操纵语言）和DCL（数据控制语言）等功能。 
   - 可以把关系数据语言分为三类：
     - 关系代数语言(ISBL,由IBM研制)
     - 关系演算语言(ALPHA/QUEL/QBE)
     - 具有关系代数和关系演算双重特点的SQL语言。
   - SQL特点：具有完备的表达能力，是非过程化的集合操作语言，功能强，可以直接交互使用也可以嵌入高级程序设计语言中使用。
4. 关系完整性约束(Integrity Constraint, IC)
   - 在数据库中数据完整性是指保证数据正确的特性，是一种语义概念。它包括两方面的内容：
     - 与现实世界中应用需求的数据的相容性和正确性； 
     - 数据库内数据之间的相容性和正确性。 
   - 在关系数据模型中一般将数据完整性分为三类： 
     - 实体完整性 
     - 参照完整性 
     - 用户定义完整性 
5. 关系模型
   - 关系模型的基本数据结构是关系：实体以及实体之间的联系都用关系来表示，并且直观来看关系就是二维表,由行和列组成
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230907090510902.png" alt="image-20230907090510902" style="zoom: 33%;" /> 
6. 关系模型的一些概念
   1. <font color='#66ccff'>关系(Relation)</font>：二维表，表名就是关系名。
   2. <font color='#66ccff'>属性(Attribute)</font>：表中的**列**称为属性，每个属性有一个在该表中唯一的属性名，列的个数称为关系的元数，有n个列的表为n元关系。
   3. <font color='#66ccff'>值域(Domain)</font>：表中属性的取值范围称为值域。
      - 不同的列可以有相同的值域
   4. <font color='#66ccff'>元组(Tuple)</font>：表中的行称为元组/记录。
   5. <font color='#66ccff'>分量(Component)</font>：元组中的每一个属性值称为元组的一个分量，n元关系的每个元组就有n个分量。
   6. <font color='#66ccff'>关系模式(Relation Schema)</font>：二维表的结构称为关系模式。设关系名为REL，属性为A1,A2,…,An,则关系模式可以表示为：REL(A1,A2,…,An)。
   7. <font color='#66ccff'>关系模型(Relation Model)</font>：所有的关系模式的总称。
   8. <font color='#66ccff'>关系数据库(Relation Database)</font>：对应于一个关系模型的所有关系的集合称为关系数据库。
      关系模型是“型”，或“内涵(Intention)”，关系数据库是“值”，或外延(Extension)。
   9. <font color='#66ccff'>候选关键字, 候选键, 候选码(Candidate Key)</font>：如果一个属性集的值能**唯一标识**该关系的元组而又**不含有多余的属性**，则称该属性集为候选关键字/候选键/候选码，一个关系可以有多个候选键。
      - <font color='#66ccff'>主属性(Primary Attribute)</font>：任一候选键中出现的属性称为主属性。
      - <font color='#66ccff'>非主属性(Nonprimary Attribute)</font>：不在任一候选键中出现的属性。
   10. <font color='#66ccff'>主关键字, 主键, 主码(Primary Key)</font>：当一个关系有多个候选键时，可以指定其中一个作为主关键字/主键/主码。每个关系有且只有一个主键。
   11. 全码(All-key): 关系的所有属性是这个关系模式的候选码
   12. <font color='#66ccff'>外部关键字, 外部键, 外码(Foreign Key)</font>：如果一个属性集不是所在关系的关键字，但是是其他关系的关键字，则该属性集称为外部关键字/外部键/外码。
   13. 参照关系(Referencing Relation)和被参照关系(Referenced Relation)：在关系数据库中通过外部键使两个关系关联，这种联系通常是一对多(1:n)的，其中主/父关系(1方)称为被参照关系，从/子关系(n方)称为参照关系。

#### 正式定义

> CODD论文的内容

1. <font color='#66ccff'>域</font>: 域是一组具有相同数据类型的值的集合
2. <font color='#66ccff'>笛卡尔积</font>：给定一组域$D_1，D_2，…，D_n$（它们可以相同），定义$D_1，D_2，…，D_n$的笛卡尔积为：
   - $D_1\times D_2\times…\times D_n = \{(d_1, d_2,\ ...\ ,d_n)| d_i\in D_i, i=1,2,..,n\}$
   - 其中每一个元素$(d_1, d_2,\ ...\ ,d_n)$叫作一个<font color='#66ccff'>n元组</font>，元组中每一个d_i叫作<font color='#66ccff'>元组的一个分量</font>。
   - 笛卡尔积就是一种所有可能的组合的运算
3. 关系的形式定义：笛卡尔积$D_1，D_2，…，D_n$ 上的一个n元关系。
4. ==注意==
   - n**集合中的元素是无序**的，关系是元组的集合，元组可以是无序的 ；但关系中的**元组的分量是有序**的。 
     例如，在关系中(a,b)≠(b,a)，但在集合中{a,b}={b,a}。
   - n若一个关系的元组个数是无限的，则该关系称为无限关系，否则称为有限关系；在数据库中只考虑有限关系。

## 2.2 关系操作



## 2.3 关系的完整性

## 2.4 关系代数

> 重点+SQL 7~8题 21~24分

| Operation          | 中文         | 符号                              | $\LaTeX$                    |
| ------------------ | ------------ | --------------------------------- | --------------------------- |
| Projection         | 投影         | $\Pi$                             | `\Pi`                       |
| Selection          | 选择         | $\sigma$                          | `\sigma`                    |
| Renaming           | 重命名       | $\rho$                            | `\rho`                      |
| Aggregate Function | 聚合函数     | $\mathcal{G}$                     | `\mathcal{G}`               |
| Union              | 交           | $\cap$                            | `\cap`                      |
| Intersection       | 补           | $\cup$                            | `\cup`                      |
| Natural Join       | 自然连接     | $\bowtie$                         | `\bowtie`                   |
| Left Outer Join    | 左外连接     | ⟕                                 | … 这几个直接复制吧          |
| Right Outer Join   | 右外连接     | ⟖                                 |                             |
| Full Outer Join    | 全外连接     | ⟗                                 |                             |
| Cartesian product  | 笛卡尔乘积   | $\times$                          | `\times`                    |
| Divide             | 除           | $$                                | `\div`                      |
| Assignment         | 赋值         | $\div$                            | `\leftarrow`                |
| And                | 条件并列     | $land$                            | `\land` or `\vee`           |
| Negation           | 非           | $neg$                             | `\neg`                      |
| Exist              | 存在         | $\exist$                          | `\exists`                   |
| For All            | 对所有       | $\forall$                         | `\forall`                   |
|                    | 下标文字     | $\sigma_{username}$               | `_{\text{}}`                |
|                    | 粗体文字     | $\mathcal{G}_{\textbf{count}}(*)$ | `\textbf{}`                 |
|                    | 长长长长括号 | ((((                              | `\big( \Big( \bigg( \Bigg(` |
|                    | 比较         | >≥<≤≠                             | `\gt \ge \lt \le \ne`       |

### 1.4.1 基本概念和几个符号

1. 关系代数的运算由如下两大类组成，即：
   - 传统的集合运算：广义笛卡尔积、集合并、集合交、集合差运算等；
   - 专门的关系运算：选择、投影、连接和除运算。
2. 关系代数中的运算符有：
   - 集合运算符：$\cap,\ \cap,\ -, \ \times$；
   - 关系运算符：$\sigma,\Pi,\infty , \div$；
   - 比较运算符：$﹥、﹤、＝、≠、≤、≥$；
   - 逻辑运算符：$﹁、∧、∨$。

3. 几个专门的符号：

   - 设有关系模式R(A1，A2，…，An) 

     - $r∈R$表示r是R的一个元组；

     - $r.A_i$或$r[A_i]$表示r这个元组中相应于属性$A_i$的一个分量； 
     - 例如，假设R是仓库关系，r=（“WH1”,“北京”,370）是仓库关系的一个元组，则r∈R ，r.仓库号或r[仓库号]为“WH1”。 

   - 设R为m元关系，S为n元关系，并且r=(r1,r2,…,rm)∈R，s=(s1,s2,…,sn)∈S，则 rs=(r1,r2,…,rm, s1,s2,…,sn)称为<font color='#66ccff'>元组的连串</font>。这是一个（m+n）元组，前m个分量为R中的一个m元组，后n个分量为S中的一个n元组。 

4. 元组中<font color='#66ccff'>属性的映像集</font>(P54)：

   - 设有关系模式**R(X**,**Y)，其中X、Y可以是单个属性，也可以是属性集，定义当X取值为x时,即r[X]=x，x在R中的映象集为：**Yx={r[Y]| r∈R **∧** r.X=x}

   - 例子：考虑订购单关系。设X={职工号}，Y={供应商号,订购单号,订购日期}，则当X取值E3时，Yx={(S7,OR67,2002/06/23), (S4,OR79,2002/07/29), (S6,OR907,2002/07/13), (S3,OR91,2002/10/27)}.

   - 例子：R(X,Z),元组有：{(x1,Z1),(x1,Z2),(x1,Z3),(x2,Z2),(x2,Z3),(x3,Z1),(x3,Z3)}

     - x1在R中的映象集Zx1={Z1,Z2,Z3}

     - x2在R中的映象集Zx2={Z2,Z3}

     - x3在R中的映象集Zx3={Z1,Z3}

### 1.4.2 运算介绍

#### 传统的集合运算

- 集合运算：∪、∩、－、×；

- $R ∪ S=\{t|t∈R∨t∈S\}$;

- $R ∩ S=\{t|t∈R∧t∈S\}$;

- $R － S=\{t|t∈R ∧ t\notin S\}$; 
  //以上要求R和S是同质的。

- $R × S=\{rs|r∈R,s∈S\}$:假设R是m元关系，有k个元组，S是n元关系，有l个元组，则R × S是m+n元关系，有k*l个元组。<font color='orange'>(笛卡尔积)</font>

#### 专门的关系运算

1. <font color='#66ccff'>选择运算$σ$</font>: 从指定的关系中选择满足某个/些逻辑条件的元组形成一个新的关系。

   - 结构不变，元组个数改变。
   - $σ_F(R)={r|r ∈ R∧F}$，这里F为结果为“真”的逻辑表达式。
   - 比如，T=σ~职工号=“E3”~(订购单); S1=σ~Sdept=“IS”~(Student)。

2. <font color='#66ccff'>投影运算$П$</font>: 从指定的关系中由部分属性及元组的相应分量形成一个新的关系。

   - 结构改变，元组个数可能改变。

   - $П_{Attr(R)}=\{r.Attr|r ∈ R\}$，这里Attr为被投影的属性/属性集。

   - 比如，T=П~职工号，供应商号~(订购单)；S2=П~Sname，Sdept~(Student) 。

3. <font color='#66ccff'>连接运算$∞_\theta$ </font>: 连接相互之间有联系的两个关系, 形成一个新的关系。参与运算的两个关系通常是具有一对多联系的引用与被引用关系,并且是通过外部键与主键的匹配而实现的.这两个键也称为连接属性.

   - 通常我们也称连接运算为$\theta$连接运算,这里$\theta$是比较运算符。当$\theta$为“=”时，称为<font color='#66ccff'>等值连接</font>，其余情况称为非等值连接；

4. <font color='#66ccff'>自然连接$∞$</font> : ①等值连接，并且②去掉重复的属性。

   - 例子：假设R(A,B,C),S(A,D,E),则R与S的$\theta$连接运算，其结果关系模式为：T(A1,B,C,A2,D,E);
     R与S的自然连接运算，其结果关系模式为：T(A,B,C,D,E)。//暂时不考虑元组。

5. <font color='#66ccff'>除运算$\div$</font>: 假设R(X,Y)和S(Y),其中X、Y是一个/组属性集，则R÷S={r.X|r∈R∧Yx Ê S}.//R为被除关系，S为除关系。商关系由R中某些X属性值构成，其中的任一X值所对应的一组Y值都包含除关系S 

## 2.5 关系演算



# 第三章 关系数据库语言SQL

3.1 SQL概述

3.2 数据定义

## 3.3 数据查询 SELECT

```sql
SELECT [ALL|DISTINCT] <表达式>[,<表达式>……]
FROM <表名>[,<表名>……]
[WHERE <逻辑表达式>]
[GROUP BY <列名>[,<列名>……][HAVING <谓词, 分组后的结果选择条件>]] 
# 按照列名在表中不同的取值进行分组 (也可以多个列名联合分组)
[ORDER BY <列名>[ASC|DESC],[<列名>[ASC|DESC]]……]
```

- 6个子句,即SELECT子句、FROM子句、WHERE子句、GROUP BY子句、HAVING子句和ORDER BY子句。

- SELECT子句表示要返回的查询结果,可为列名或涉及列的表达式,可用*表示表中的所有列
  - ALL说明不去掉重复元组,DISTINCT说明要去掉重复元组.

- FROM子句说明要查询的数据来自哪个or些表.由此,查询也常常分为单表查询和多表查询
- WHERE子句说明要查询的数据应该满足哪个/些条件.可以用于查询条件的运算符有:
  - 比较: =,>,>=,<,<=,!=,<>,!>,!<
  - 确定范围: BETWEEN  AND, NOT BETWEEN  AND
  - 确定集合: IN, NOT IN
  - 字符匹配: LIKE, NOT LIKE
  - 空值: IS NULL, IS NOT NULL
  - 否定: NOT
  - 多重条件: AND, OR
- GROUP BY子句用于对于查询结果进行分组//分组汇总.
  - HAVING子句必须跟随GROUP BY子句使用,它用来限定分组必须满足的条件 
    如 `count(*)>=50`, 组内的记录数要>=50
- ORDER BY子句用来对查询的结果进行排序.

### 3.3.? 嵌套查询（子查询）

#### 二. 使用量词的嵌套查询

在嵌套查询中可以使用ANY、SOME、ALL等量词，它们的形式是：

```sql
<表达式> <比较运算符> [ANY|ALL|SOME] (子查询)
```

- 其中ANY和SOME是同义词，在进行比较运算时只要子查询中有一行能使结果为真，则结果就为真；
  而ALL则要求子查询中的所有行都使结果为真时，结果才为真。



**例: 检索有职工的工资大于或等于WH1仓库中任任意一名职工的工资的仓库号**

<img src="assets/image-20230926103125325.png" alt="image-20230926103125325" style="zoom:50%;" /> 

- ```sql
  SELECT DISTINCT 仓库号 FROM 职工 
  WHERE 工资 >= ANY (SELECT 工资 FROM 职工 WHERE 仓库号= 'WH1'); 
  # 等价于
  SELECT DISTINCT 仓库号 FROM 职工 
  WHERE 工资 >= (SELECT MIN(工资)  FROM 职工 WHERE 仓库号= 'WH1');
  ```

- 结果：WH1，WH2，WH3



#### 三. 内、外层互相关嵌套查询

普通的嵌套查询都是外层查询依赖于内层查询的结果，而内层查询与外层查询无关。

事实上，有时也需要内、外层互相关的查询，即内层查询需要外层查询提供数据，而外层查询又依赖内层查询的结果，将这种查询命名为<font color="66ccff">相关子查询</font>(其他子查询就叫普通子查询)



**例：在订购单关系中加入一个新字段总金额，说明完成该订购单所应付出的总金额数**

![image-20230926103919572](assets/image-20230926103919572.png)

查询要求：列出每个职工经手的具有最高总金额的订购单信息 //未确定因素:每个职工有多少单?

- ```sql
  SELECT *
  FROM 订购单 outa
  WHERE 总金额 = (SELECT MAX(总金额)
               	FROM 订购单 innera
               	WHERE outa.职工号 = innera.职工号); 
  ```
  
- 结果是：

  ```sql
  E7  S4   OR76  2002-05-25   7250.00
  E6  S6   OR77  2002-06-29   6000.00
  E3  S7   OR67  2002-06-23  35000.00
  E1  S6   OR80  2002-07-29  25600.00
  ```

#### 四. 使用EXISTS的嵌套查询

在嵌套查询中还可以使用[NOT] EXISTS，具体形式是：

```sql
[NOT] EXISTS (子查询)
```

`EXISTS`或`NOT EXISTS`是用来检查在子查询中==是否有结果返回==（即存在元组或不存在元组．注意，这里不能用“＝”）。



例题：检索那些仓库中还没有职工的仓库的信息。

<img src="assets/image-20230926103125325.png" alt="image-20230926103125325" style="zoom:50%;" /> 

- ```sql
  SELECT * FROM 仓库 WHERE NOT EXISTS # 没有在该仓库中的员工
  	(SELECT * FROM 职工 WHERE 仓库号 = 仓库.仓库号); # 在该仓库中的员工
   # 等价于
   SELECT * FROM 仓库 WHERE 仓库号 NOT IN
      (SELECT 仓库号 FROM 职工); # 有职工的仓库
  ```

- 结果是：`WH4 武汉 400`



例题：检索那些仓库中至少已经有一个职工的仓库的信息

<img src="assets/image-20230926103125325.png" alt="image-20230926103125325" style="zoom:50%;" /> 

- ```SQL
  SELECT * FROM 仓库 WHERE EXISTS 
  	(SELECT * FROM 职工 WHERE 仓库号=仓库.仓库号)
  ```

#### 五. 分组计算及查询

SQL语言不仅可以从数据库中查询原始信息，而且还可以直接对查询结果进行计算和汇总。

SQL语言支持分组的计算和汇总。

用于计算检索的函数主要有：

- COUNT——计数 
-  SUM——求和 
- AVG——计算平均值
- MAX——求最大值 
- MIN——求最小值 

这些函数称为聚合函数,可以在SELECT子句中对查询结果进行计算,或在HAVING子句中根据查询结果限定分组.



GROUP BY子句可以进行分组计算.如果在SELECT子句中同时出现单个/多个属性和聚合函数,则必须按所出现的属性进行分组。

```sql
SELECT 仓库号,AVG(工资) FROM 职工 GROUP BY 仓库号;
SELECT 仓库号,职工号,AVG(工资) FROM 职工 GROUP BY 仓库号;
```

- GROUP BY子句能完成汇总，但是却不能显示细节。 
- 利用COMPUTE子句，汇总结果是附加在细节之后显示的，这样用户既能看到细节，又能看到汇总行。 

##### COMPUTE

```sql
COMPUTE <函数名>(<列名>)[,<函数名>(<列名>)…] [BY <列名>[,<列名>…]]
```

- 这里<函数名>只能是用于SELECT计算查询的函数SUM、AVG、MIN、MAX和COUNT等。 
- COMPUTE子句中的BY子句是用来说明分组的，如果在COMPUTE子句中不使用BY子句，则是对整个表进行汇总。
  - 这里使用BY子句，也必须使用ORDER BY子句，BY子句指出的列必须和ORDER BY子句指出的列顺序相同，但BY子句的列数可以少于ORDER BY子句的列数。

### 3.4 数据更新

3.5 空值的处理

### 3.6 视图

> 通过create table创建的表，基本表base table；create view视图=虚表
>
> 视图可以动态地反映数据库的状态
>
> - 注意与快照的区别

视图的作用:

1. 保密;
2. 动态反映数据库状态;
3. 利用视图回答用户的查询(Answering queries using views).
4. 简化查询语句（作为多个查询的公因子）

#### 视图定义

视图是根据对基本表的查询定义的，其命令格式如下：

```sql
CREATE VIEW <视图名> AS <SELECT-查询块>
```

- 从单个表派生出的视图
- 从多个表派生出的视图
- 视图中的虚列

定义视图的例子

```sql
CREATE  VIEW  v_bj  AS
SELECT  仓库号，面积
FROM  仓库
WHERE  城市 = '北京' ;
# 基于视图进行查询：
SELECT * FROM  v_bj;

CREATE  VIEW  e_w  AS
SELECT  职工号，仓库号
FROM  职工; 
#基于视图进行查询：
SELECT * FROM  e_w;
```



定义一个虚列

```sql
CREATE VIEW v_sal(职工号,月工资,年工资) AS #v_sal即为定义出来的虚列
SELECT 职工号,工资,工资*12 FROM 职工;
```

