# 进程
[TOC]
## 定义

1. 操作系统必须全方位地管理计算机系统中运行的程序。因此，操作系统为正在运行程序建立一个管理实体——进程
2. 进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动
3. 进程是操作系统进行资源分配和调度的一个独立单位

### 一个进程包括五个部分

1. （OS管理运行程序的）数据结构P
2. （运行程序的）内存代码C
3. （运行程序的）内存数据D
4. （运行程序的）通用寄存器信息R
5. （OS控制程序执行的）程序状态字信息PSW

### 概念级的进程状态

1. 运行态：进程占有处理器运行
2. 就绪态：进程具备运行条件等待处理器运行
3. 等待态：进程由于等待资源、输入输出、信号等而不具备运行条件

### 三态模型

1. 运行态→等待态：等待资源、I/O、信号
2. 等待态→就绪态：资源满足、I/O结束、信号完成
3. 就绪态→运行态；处理器空闲时选择更高优先权进程抢占
4. 运行态→就绪态：运行时间片刻、有更高优先权进程

### 进程挂起

1. OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况
2. 运行资源不足表现为性能低和死锁两种情况
3. 解决办法（进程挂起）：剥夺某些进程的内存及其他资源，调入OS管理的对换区，不参加进程调度，待适当时候再调入内存、恢复资源、参与运行
4. 挂起态与等待态有着本质区别，后者占有已申请到的资源处于等待，前者没有任何资源

### 进程挂起的选择与恢复

1. 选择等待态、就绪态进程进入挂起等待态
2. 运行态进程可以挂起自己
3. 等待事件结束后，挂起就绪态
4. 一般选择挂起就绪态进程予以恢复

## 进程控制块（Process Control Block）

### PCB是OS用于记录和刻画进程状态及环境信息的数据结构
### 借助PCB，OS可以全面管理进程物理实体，刻画进程的执行现状，控制进程的执行
### 划分
#### 标识信息

1. 进程标识
2. 用于存放唯一标识该进程的信息
    1. 系统分配的标识号
    2. 系统分配的进程组标识号
    3. 用户定义的进程名
    4. 用户定义的进程组名

#### 现场信息

1. 用户可见寄存器内容
2. 控制/状态寄存器内容
3. 用户/核心栈指针
4. 用于存放该进程运行时的处理器现场信息
    1. 用户可见寄存器内容：数据寄存器、地址寄存器
    2. 控制与状态寄存器内容：PC、IR、PSW
    3. 栈指针内容：核心栈与用户栈指针

#### 控制信息：用于存放与管理、调度进程相关的信息

1. 调度相关信息：状态、等待事件/原因、优先级
2. 进程组成信息：代码/数据地址、外存映像地址
3. 队列指引元：进程队列指针、父子兄弟进程指针
4. 通信相关信息：消息队列、信号量、锁
5. 进程特权信息：内存访问权限、处理器特权
6. 处理器使用信息：占用的处理器、时间片、处理器使用事件/已执行总时间、记账信息
7. 资源清单信息：正占用的资源、已使用的资源

## 进程切换与模式切换

1. 一些中断/异常不会引起进程状态转换，不会引起进程切换，只是在处理完成后把控制权交回给被中断进程

### 处理流程：
1. （中断/异常触发）正向模式切换压入PSW/PC
2. 保存被中断进程的现场信息
3. 处理中断/异常
4. 恢复被中断进程的现场信息
5. （中断返回指令触发）逆向模式转换弹出PSW/PC

## 模式切换（处理器状态切换）

1. 进程切换必须在操作系统内核模式下完成，这就需要模式切换

### 切换：

1. 用户模式到内核模式：由中断/异常/系统调用中断用户进程执行而触发
2. 内核模式到用户模式：OS执行中断返回指令将控制权交还用户进程而触发

### 基本工作任务

1. 中断装置完成正向模式切换，包括：
    1. 处理器模式转为内核模式
    2. 保存当前进程的PC/PSW值到核心栈
    3. 转向中断/异常/系统调用处理程序
2. 中断返回指令完成逆向模式转换，包括：
    1. 从待运行进程核心栈中弹出PSW/PC值
    2. 处理器模式转为用户模式

## 进程切换
### 进程切换指从正在运行的进程中收回处理器，让待运行进程来占有处理器运行
### 进程切换实质上就是被中断运行进程与待运行进程的上下文切换，处理过程：

1. 保存被中断进程的上下文
2. 转向进程调度
3. 恢复待运行进程的上下文

### 工作过程

1. （中断/异常等触发）正向模式切换并压入PSW
2. 保存被中断进程的现场信息
3. 处理具体中断/异常
4. 把被中断进程的系统堆栈指针SP值保存到PCB
5. 调整被中断进程的PCB信息，如进程状态
6. 把被中断进程的PCB加入相关队列
7. 选择下一个占用CPU运行的进程
8. 修改被选中进程的PCB信息，如进程状态
9. 设置被选中进程的地址空间，恢复存储管理信息
10. 恢复被选中进程的SP值到处理器寄存器SP
11. 恢复被选中进程的现场信息进入处理器
12. （中断返回指令触发）逆向模式转换并弹出PSW/PC

### 发生时机：进程切换一定发生在中断/异常/系统调用处理过程中

1. 阻塞式系统调用、虚拟地址异常导致被中断进程进入等待态
2. 时间片中断、I/O中断后发现更高优先级进程导致被中断进程转入就绪态
3. 终止用系统调用、不能继续执行的异常导致被中断进程进入终止态

## 原语与进程控制原语

1. 进程控制过程中涉及对OS核心数据结构（进程表/PCB池/队列/资源表）的修改
2. 为防止与时间有关的错误，应使用原语
3. 原语是由于若干条指令构成的完成某种特定功能的程序，执行上具有不可分割性
4. 原语的执行可以通过关中断实现
5. 进程控制使用的原语称为进程控制原语
6. 另一类常用原语是进程通信原语

## 进程的控制与管理

1. 进程创建：进程表加一项，申请PCB并初始化，生成标识，建立映像，分配资源，移入就绪队列
2. 进程撤销：从队列中移除，归还资源，撤销标识，回收PCB，移除进程表项
3. 进程阻塞：保存现场信息，修改PCB，移入等待队列，调度其他进程执行
4. 进程唤醒：等待队列中移除，修改PCB，移入就绪队列（该进程优先级高于运行进程触发抢占）
5. 进程挂起：修改状态并出入相关队列，收回内存等资源送至对换区
6. 进程激活：分配内存，修改状态并出入相关队列
7. 其他：如修改进程特权

## 队列管理模块

1. 队列管理模块是操作系统实现进程管理的核心模块
2. 操作系统建立多个进程队列，包括就绪队列和等待队列
3. 按需组织为先进先出队列与优先队列
4. 队列中的进程可以通过PCB中的队列指引元采用单/双指引元或索引连接
5. 出队与入队操作
6. 进程与资源调度围绕进程队列展开

## 关键的进程管理软件

### 系统调用/中断/异常处理程序
### 队列管理模块
### 进程控制程序
### 进程调度程序（独立进程居多）
### 进程通信程序（多个程序包）
### 终端登陆与作业控制程序、性能监控程序、审计程序等外围程序

## 进程上下文（Process context）

1. 进程的执行需要环境支持，包括CPU现场和Cache中的执行信息
2. OS中的进程物理实体和支持进程运行的环境合成进程上下文，包括以下：
    1. 用户级上下文：用户程序块/用户数据区/用户栈/用户共享内存
    2. 寄存器上下文：PSW/栈指针/通用寄存器
    3. 系统级上下文：PCB/内存区表/核心栈
3. 进程上下文刻画了进程的执行情况

## 进程映像（Process Image）
1. 某一时刻进程的内容及其执行状态集合
    1. 进程控制块：保存进程的标识信息、状态信息和控制信息
    2. 进程程序块：进程处理的数据空间，包括数据、处理函数的用户栈可修改的程序
    3. 核心栈：进程在内核模式下运行时使用的堆栈，中断或系统过程使用
2. 进程映像是内存级的物理实体，又称为进程的内存映像

## 线程
### 传统进程是单线程结构进程
#### 问题：

1. 进程切换开销大
2. 进程通信开销大
3. 限制了进程并发的粒度
4. 降低了并行计算的效率

#### 解决思路：

1. 分离两个功能，”独立分配资源“与”被调度分派执行“
2. 进程作为系统资源分配和保护的独立单位，不需要频繁地切换
3. 线程作为系统调度和分派的基本单位，能轻装运行，会被频繁地调度和切换
4. 线程的出现会减少进程并发执行所付出的时空开销，使得并发粒度更细、并发性更好

### 多线程环境下进程的概念
1. 在多线程环境中，进程是操作系统中进行保护和资源分配的独立单位，具有：
    1. 用来容纳进程映像的虚拟地址空间
    2. 对进程、文件和设备的存取保护机制

### 多线程环境下线程的概念

1. 线程是进程的一条执行路径，是调度的基本单位，同一个进程中的所有线程共享进程获得的主存空间和资源。它具有：
    1. 线程执行状态
    2. 受保护的线程上下文，当线程不运行时，用于存储线程信息
    3. 独立的程序指令计数器
    4. 执行堆栈
    5. 容纳局部变量的静态存储器

### 多线程环境下线程的状态与调度

1. 线程状态有运行、就绪和睡眠，无挂起
2. 与线程状态变化有关的线程操作有：
    1. 孵化、封锁、活化、剥夺、指派、结束
3. OS感知线程环境下：
    1. 处理器调度对象是线程
    2. 进程没有三状态（或者说只有挂起状态）
4. OS不感知线程环境下：
    1. 处理器调度对象仍是进程
    2. 用户空间中的用户调度程序调度线程

### 并发多线程程序设计的优点

1. 快速线程切换
2. 减少（系统）管理开销
3. （线程）通信易于实现
4. 并行程序提高
5. 节省内存空间

### 多线程技术的应用

1. 前台和后台工作
2. C/S应用模式
3. 加快执行速度
4. 设计用户接口

### 内核级线程（KLT，Kernel-Level Threads）

1. 线程管理的所有工作由OS内核来做
2. OS提供了一个应用程序设计接口API，供开发者使用KLT
3. OS直接调度KLT
4. KLT适用于解决物理并行性问题
5. 特点
    1. 进程中的一个线程被阻塞了，内核能调度同一进程的其他线程占用处理器运行
    2. 多处理器环境中，内核能同时调度同一进程中多个线程并行执行
    3. 内核自身也可用多线程技术实现，能提高操作系统的执行速度和效率
    4. 应用程序线程在用户态运行，线程调度和管理在内核实现，在同一进程中，控制权从一个线程传送到另一个线程时需要模式切换，系统开销较大

### 用户级线程（ULT，User-Level Threads）
1. 用户空间运行的线程库，提供多线程应用程序的开发和运行支撑环境
2. 任何应用程序均需通过线程库进行程序设计，再与线程库连接后运行
3. 线程管理的所有工作都由应用程序完成，内核没有意识到线程的存在
4. ULT适用于解决逻辑并行性问题
5. 特点
    1. 所有线程管理数据结构均在进程的用户空间中，线程切换不需要内核模式，能节省模式切换开销和内核的宝贵资源
    2. 允许进程按应用特定需要选择调度算法，甚至根据应用需要裁剪调度算法
    3. 能运行在任何OS上，内核在支持ULT方面不需要做任何工作
    4. 不能利用多处理器的优点，OS调度进程，仅有一个ULT能执行
    5. 一个ULT的阻塞，将引起整个进程的阻塞

### Jacketing技术

1. 把阻塞式系统调用改造成非阻塞式的
2. 把线程陷入系统调用时，执行jacketing程序
3. 由jacketing程序来检查资源使用情况，以决定是否执行进程切换或传递控制权给另一个线程

### 多线程实现的混合式策略

1. 线程创建是完全在用户空间做的
2. 单应用的多个ULT可以映射成一些KLT，通过调整KLT数目，可以达到较好的并行效果
3. 特点
    1. 组合ULT/KLTs设施
    2. 线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行
    3. 一个应用中的多个ULT被映射到一些（小于等于ULT数目）内核级线程上
    4. 程序员可以针对特定应用和机器调节KLT数目，以达到整体最佳结果
    5. 该方法将会结合纯粹ULT方法和KLT方法的优点，同时减少它们的缺点

### 线程混合式策略下的线程状态

1. KLT负责三态，系统调用负责
2. ULT负责三态，用户调度负责
3. 活跃态ULT代表绑定KLT的三态
4. 活跃态ULT运行时可激活用户调度
5. 非阻塞系统调用可使用Jacketing启动用户调度，调整活跃态ULT
