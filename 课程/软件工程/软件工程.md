# 第1章 软件的本质

## 1.1 软件的本质

1. 软件的双重角色

   - 软件是一种**产品**：
     - 扮演着信息转换的角色；
     - 产生、管理、查询、修改、显示、传递信息。
   - 软件是生产产品的**载体**，提供以下基础平台：
     - 计算机控制 (e.g., 操作系统)
     - 信息通信 (e.g., 网络软件)
     - 应用软件开发 (e.g., 软件工具)
2. 现在，一个庞大的**软件产业**已经成为了工业经济中的**主导因素**。早期的独立程序员也已经被专业的**软件开发团队**所代替，团队中的不同专业技术人员可分别关注复杂的应用系统中**某一个技术部分**。然而同过去独立程序员一样，开发现代计算机系统时，软件开发人员依然面临同样的问题：

   - 为什么软件需要如此长的**开发时间**？

   - 为什么开发**成本**居高不下？

   - 为什么在将软件交付顾客使用之前，我们无法找到所有的**错误**？

   - 为什么**维护**已有的程序要花费高昂的时间和人力代价？

   - 为什么软件开发和维护的过程仍旧**难以度量**？

3. 什么是软件
   - 软件是==<font color='#66ccff'>程序, 文档, 数据</font>的集合==
   - 程序的正常运行离不开必要的文档和数据：
     - <font color='#66ccff'>文档</font>: 是开发、使用和维护程序所需要的**图文资料**；
     - <font color='#66ccff'>数据</font>: 是使程序能够适当地处理信息的数据结构（包括**数据库**、一些**配置文件**等
4. 软件和硬件的区别
   1. 软件是设计开发的，而不是传统意义上**生产制造**的：
      - 硬件和软件可通过优秀的设计获得高品质产品，然而硬件在制造阶段可能会引入质量问题，这在软件中并不存在（或者易于纠正）；
      - **软件成本主要在于开发设计**，硬件的成本在批量生产时仍然很高。
      - 硬件失效曲线 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230904200355840.png" alt="image-20230904200355840" style="zoom: 33%;" /> 
        硬件早期因设计/生产缺陷, 有较高失效率; 缺陷纠正后, 失效率保持平稳; 随着硬件损耗, 失效率提高
      - 软件失效曲线 <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230904200752427.png" alt="image-20230904200752427" style="zoom:33%;" /> 
        软件每次变更可能解决一些问题, 但同时也会引入新的错误, 也会造成软件可维护性的下降
      - **软件工程方法的目的即在于使实际曲线能与理想曲线接近**
   2. 软件不会“磨损” ：
      - 磨损的硬件部件可以用备用部件替换，而软件却不存在备用部件。
      - 每个软件的缺陷都暗示了设计的缺陷或者在从设计转化到机器可执行代码（实现）的过程中产生的错误。
      - 软件维护要应对变更请求，比硬件维护更为复杂。
      - 不断的变更是软件退化的根本原因。
   3. 基于构件的构造模式：
      - 工程学科的发展将产生一系列标准的设计器件。可复用构件的使用可以使得工程师专心于设计中真正创新的部分。
      - 在硬件设计中，构件复用是工程进程中通用的方法 (例如，标准螺丝钉、可订购的集成电路)。 
      - 现代可复用软件构件封装了数据和对数据的处理。例如，图形窗口、下拉菜单和各种交互机制。

### 1.1.2 软件应用领域

1. 系统软件：

   - <font color='#66ccff'>系统软件是一整套服务于其他程序的程序</font>：

     - 某些系统软件（例如：编译器、编辑器、文件管理软件）处理复杂但确定的信息结构。

     - 另一些系统应用程序（例如：操作系统构件、驱动程序、网络软件、远程通信处理器）主要处理的是不确定的数据。

   - 系统软件多具有以下特点：
     - 和计算机**硬件大量交互**；
     - **多用户**大量使用；
     - 需要调度、资源共享和复杂进程管理的同步操作；
     - 复杂的数据结构以及多种外部接口。 

2. <font color='#66ccff'>应用软件</font>：

   - 解决特定业务需要的独立应用程序。
   - 除了传统数据处理的应用程序，应用软件也被用于业务功能的实时控制，例如：
     - 销售点的交易处理
     - 实时制造过程控制

3. <font color='#66ccff'>工程／科学软件</font>：

   - 这类软件通常带着“数值计算”算法的特征，工程和科学软件涵盖了广泛的应用领域，从天文学到火山学，从自动应力分析到航天飞机轨道动力学，从分子生物学到自动制造业。
   - MATLAB, CAD

4. <font color='#66ccff'>嵌入式软件</font>：

   - 嵌入式软件存在于某个产品或者系统中。
   - 嵌入式软件可以执行有限但难于实现的功能，例如：
     - 微波炉的按键控制
   - 提供重要的功能和控制能力，例如：
     - 汽车中的燃油控制
     - 仪表板显示
     - 刹车系统等汽车电子功能 

5. 产品线软件：

   - 产品为多个不同用户的使用提供特定功能。

   - 产品线软件关注有限的特定的专业市场，例如库存控制产品
   - 大众消费品市场，例如
     - 文字处理
     - 电子制表软件
     - 电脑绘图
     - 多媒体
     - 娱乐
     - 数据库管理
     - 个人及公司财务应用

6. Web应用软件：

   - 叫做“Web应用”（WebApp），是一类以**网络为中心的软件**，其概念涵盖了宽泛的应用程序产品。最简单可以是一组超文本链接文件，仅仅用文本和有限的图形表达信息。
   - 随着Web 2.0的出现，网络应用正在发展为复杂的计算环境：
     - 比如，网游、网络社区应用

7. 人工智能软件：

   - 人工智能软件利用**非数值算法**解决计算和直接分析无法解决的复杂问题。
   - 这个领域的应用程序包括：
     - 机器人
     - 专家系统
     - 模式识别（图像和语音）
     - 人工神经网络
     - 定理证明和博弈等。

8. 开放计算：无线网络的快速发展会促成普适计算、分布式计算、以及云计算的发展。软件工程师面临的挑战是开发系统和应用软件，使得移动设备、个人电脑和企业应用可以通过网络设施进行通信。

9. 开源软件：代码开放将成为一种趋势。

### 1.1.3 遗留软件

1. 遗留软件特点

   - 开发年代久远。

   - 一直在使用。

   - 在使用过程中被不断地修改以满足商业需要和计算平台的变化。

   - 可能仍然支持着核心业务。
     - 质量差：
       - 设计难以扩展
       - 代码令人费解
       - 文档混乱，可能缺失
       - 变更管理混乱
       - 测试记录未归档

   - 由于遗留软件常常支撑着核心业务，对其变更必须非常谨慎。如果它能够满足用户的需求并可靠运行，则<font color='#EE0000'>不要修改它</font>。

2. 遗留软件为什么要演化?

   - 进行适应性变化，以满足新的计算环境或者技术的需要
   - 根据新的业务需求进行升级
   - 扩展以及具有与更多现代系统或数据库的协作能力
   - 改建以适应多样化的网络环境

## 1.2 软件的变更本质

1. 四类新的软件

   1. WebApp
      - 在本书中，WebApp 这个术语包含了很多事物，从一个简单的帮助消费者计算汽车租借费用的网页，到为商务旅行和度假提供全套旅游服务的大型复杂的Web 站点。

   2. 移动App
      - iOS，Android等，移动WebApp与移动App之间有微妙差异。WebApp允许移动设备通过针对移动平台的优点和弱点专门设计的浏览器获取基于Web内容的访问。移动App可以直接访问设备的硬件特性（例如加速器或者GPS定位），然后提供前面所述的本地处理和存储能力。
   3. 云计算 : 程序在云端服务器运行
      <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230904204250820.png" alt="image-20230904204250820" style="zoom:50%;" />

   4. 产品线软件
      - 软件产品线都使用**相同的底层**应用软件和数据体系结构来开发，并使用可在整个产品线中进行**复用的一组软件构件**来实现

# 第2章 软件工程

## 2.1 定义软件工程学科

1. 软件工程定义

   - Fritz Bauer [Nau69]

     建立和使用一套合理的工程原则，从而经济地获得可靠的、可在实际机器上高效运行的软件。

   - IEEE [IEEE93a]

     将系统化的、规范化的、可量化的方法应用于软件的开发、运行和维护，即将工程化的方法应用于软件；

   - 以上所述方法的研究。

2. 软件工程层次图

   - <font color='#66ccff'>软件工程工具</font> (tool)为过程和方法提供自动化或半自动化的支持
   - <font color='#66ccff'>软件工程方法</font>（method）为构建软件提供技术上的解决方法（“如何做”）。包括沟通、需求分析、设计建模、编程、测试和技术支持。
   - <font color='#66ccff'>过程</font>定义了一个框架，给出了开发步骤。
   - <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230904204939961.png" alt="image-20230904204939961" style="zoom:33%;" /> 



## 2.2 软件过程

1. 什么是软件过程
   - <font color='#66ccff'>过程</font>是事情进行或事物发展所经过的顺序。 
   - 当开发产品或构建系统时，遵循一系列**可预测的步骤**（即路线图）是非常重要的，它有助于及时交付高质量的产品。
   - 软件开发中所遵循的路线图就称为“<font color='#66ccff'>软件过程</font>”。
2. 软件工程过程框架
   - <font color='#66ccff'>框架</font>：事物的基本组织、结构
   - 过程框架：
     - 定义了若干小的**框架活动**，为完整的软件开发过程建立了基础
       - 煮饺过程的框架活动包括：下锅、搅锅、煮沸、煮馅；
     - 每一个活动由一组**软件工程动作**组成：
       - “煮馅”活动包括三组“冷水止沸”动作；
     - 每一个动作都包括一系列相互关联的可考核的任务。
       - 每一个任务完成一个动作定义的一部分工作。
       - “冷水止沸”包括“加冷水”，“煮沸”两个相关联的任务；
   - <font color='#66ccff'>通用过程框架</font>—适用于绝大多数软件项目，包含五个最基本的框架活动：沟通、策划、建模、构建、部署： 
     - **沟通**。在技术工作开始之前，和客户（及其他利益相关者）的沟通与协作是极其重要的；其目的是理解利益相关者的项目目标，并收集需求以定义软件特性和功能。  
     - **策划**。也可以称为软件项目计划，它定义和描述了软件工程工作，包括需要执行的技术任务、可能的风险、资源需求、工作产品和工作进度计划。 
     - **建模**。利用模型来更好地理解软件需求，并完成符合这些需求的软件设计。
     - **构建**。它包括编码（手写的或者自动生成的）和测试以发现编码中的错误。
     - **部署**。软件（全部或者部分增量）交付到用户，用户对其进行评测并给出反馈意见。
3. <font color='#66ccff'>普适性活动</font>
   - 软件工程过程框架活动由很多普适性活动来补充实现。
     通常，这些普适性活动贯穿软件项目始终，以帮助软件团队管理和控制项目进度、质量、变更和风险。
   - 典型的普适性活动包括：
     - **软件项目跟踪和控制**—项目组根据计划评估项目进度，并且采取必要的措施保证项目按进度计划进行。
     - **风险管理**—对可能影响项目成果或者产品质量的风险进行评估。
     - **软件质量保证**—确定和执行软件质量保证的活动。
     - **技术评审**—评估软件工程产品，尽量在错误传播到下一个活动之前，发现并清除错误。
     - **测量**—定义和收集过程、项目和产品的度量，以帮助团队在发布软件的时候满足利益相关者要求。
     - **软件配置管理**—在整个软件过程中，管理变更所带来的影响。
     - **可复用管理**—定义产品复用的标准（包括软件构件），并且建立构件复用机制。
     - **工作产品的准备和生产**—诸如建模、文档、日志、表格和列表等。
4. **过程的适应性调整**
   - 软件工程过程并不是教条的法则，不要求软件团队机械地执行；而应该是灵活可适应的（根据软件所需解决的问题、项目特点、开发团队和组织文化等进行适应性调整）。
     因此，不同项目所采用的项目过程可能有很大不同。这些不同主要体现在以下几个方面： 
     - 活动、动作和任务的**总体流程**，以及相互依赖关系。
     - 在每一个框架活动中，动作和任务**细化的程度**。
     - 工作产品的**定义和要求的程度**。
     - **质量保证活动**应用的方式。
     - **项目跟踪和控制活动**应用的方式。
     - **过程描述**的详细程度和严谨程度。
     - 客户和利益相关者对**项目参与的程度**。
     - 软件团队所赋予的**自主权**。
     - 队伍组织和**角色明确程度**。

## 2.3 软件工程实践

> 软件工程实践的**精髓**：
>
> 1. 理解问题（沟通和分析）
>
> 2. 计划解决方案（建模和软件设计）
>
> 3. 实施计划（代码生成）
>
> 4. 检查结果的正确性（测试和质量保证）

1. <font color='#ee0000'>理解问题</font>。

   - 谁将从问题的解决中**获益**？也就是说，谁是利益相关者？
   - 有哪些是**未知**的？哪些数据、功能、特征和行为是解决问题必需的？
   - 问题可以**划分**吗？是否可以描述为更小、更容易理解的问题？
   - 问题可以**图形化描述**吗？可以建立分析模型吗？

2. <font color='#EE0000'>计划解决方案</font>。在编码之前，稍稍慢下来做一点点设计：

   - 以前曾经见过**类似问题**吗？在潜在的解决方案中，是否可以**识别一些模式**？
   - 是否**已经有软件实现**了所需要的数据、功能、特征和行为？
   - **类似问题是否解决过**？如果是，解决方案所包含元素是否可以复用？
   - 可以**定义子问题**吗？如果可以，子问题是否已有解决方案？
   - 能用一种可以**快速实现**的方式来描述解决方案吗？能构建出设计模型吗？

3. <font color='#EE0000'>实施计划</font>。保证在实施过程中**不至于迷失方向~~MyGo~~**。需要考虑的问题是：

   - 解决方案**和计划一致**吗？

   - 源码是否可**追溯到设计模型**？

   - 解决方案的每个组成部分是否可以**证明正确**？

   - 设计和代码是否经过**评审**？

   - 或者更好的算法是否经过**正确性证明**？

4. <font color='#EE0000'>检查结果 (测试)</font>。你不能保证你的解决方案是最完美的，但是你可以保证**设计足够的测试**来发现尽可能多的错误。为此，需回答：

   - 能否测试解决方案的每个部分？

   - 是否实现了合理的测试策略？
   - 解决方案是否产生了与所要求的数据、功能、特征和行为一致的结果？
   - 是否按照项目共同利益者的需求进行了确认？

#### 软件工程的一般原则

> David Hooker的7个关注软件工程整体实践原则:

第1原则：存在价值

> 一个软件系统因能给用户提供价值而具有存在价值，所有的决定都应该基于这个思想。
>
> 在确定系统需求之前，在关注系统功能之前，在决定硬件平台或者开发过程之前，问问你自己：
>
> - 这确实能为系统增加真正的价值吗？
> - 如果答案是不，那就坚决不做。所有的其他原则都以这条原则为基础。 

第2原则：保持简洁 (设计方面)

> 所有的设计都应该尽可能简洁，但不是过于简化。这有助于构建更易于理解和易于维护的系统。
>
> 这并不是说那些特征甚至是内部特征应该以“简练”为借口而取消。的确，优雅的设计通常也是简洁的设计，简练也不意味着“快速和粗糙”。
>
> 事实上，简洁经常是经过大量思考和多次工作迭代才达到的，这样做的回报是得到的软件更易于维护且存在更少错误。

第3原则：保持愿景 (目标清晰明确，无歧义)

> 清晰的愿景是软件项目成功的基础。没有愿景，项目将会由于它有“两种或者更多种思想”而永远不能结束；
>
> 如果缺乏概念的一致性，系统就好像是由许多不协调的设计补丁、错误的集成方式强行拼凑在一起......如果不能保持软件系统体系架构的愿景，将削弱甚至彻底破坏设计良好的系统。
>
> 授权体系架构师，使其能够保持愿景，并保证系统实现始终与愿景保持一致，这对项目开发成功至关重要。

第4原则：关注使用者

> 通常软件系统必定是由开发者以外的人员使用、维护和编制文档等，这就必须要让别人理解你的系统。
> 因此，需求说明时应时刻想到用户；设计中始终想到实现；编码时想着那些要维护和扩展系统的人。

第5原则：面向未来 

> 生命期持久的系统具有更高的价值。在现今的计算环境中，需求规格说明随时会改变，硬件平台几个月后就会淘汰。
> 然而，真正具有“产业实力”的软件系统必须持久耐用。系统必须能适应这样那样的变化，能成功做到这一点的系统都是那些一开始就以这种路线设计的系统。
> 永远不要把自己的设计局限于一隅，经常问问：“如果出现......应该怎样应对”，构建可以解决通用问题的系统，为各种可能的方案做好准备，这很可能会提高整个系统的可复用性。

第6原则：提前计划复用

> 复用既省时又省力。软件系统开发过程中，高水平的复用是很难实现的一个目标。
> 代码和设计复用曾宣称是面向对象技术带来的主要好处，然而，这种投入回报不会自动实现。为达到面向对象（或是传统）程序设计技术所能够提供的复用性，需要有前瞻性的设计和计划。

第7原则：认真思考

> 这最后一条规则可能是最容易被忽略的。
> 在行动之前清晰定位、完整思考通常能产生更好的结果。
> 如果仔细思考过后，还是把事情做错了，那么，这就变成了很有价值的经验。

## 2.4 软件开发神话

略

## 2.5 这一切是如何开始的

每个软件工程项目都来自业务需求：

- 对现有应用程序缺陷的纠正；
- 改变遗留系统以适应新的业务关键；
- 扩展现有应用程序功能和特性；
- 开发某种新的产品、服务或系统。

软件项目的初期，业务需求通常是在谈话过程中非正式地表达出来。



# 第3章 软件过程结构

## 3.1 通用过程模型

1. 软件过程
   - 通用过程框架定义了五种框架活动：**①沟通 ②策划 ③建模 ④构建 ⑤部署**
2. 过程流 : 线性, 迭代, 演化, 并行
   - <font color='#66ccff'>线性过程流</font>
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230908102521643.png" alt="image-20230908102521643" style="zoom:50%;" />
   - <font color='#66ccff'>迭代过程流</font>
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230908102539887.png" alt="image-20230908102539887" style="zoom:50%;" />
     **在执行下一个活动前重复执行之前的一个或多个活动**
   - <font color='#66ccff'>演化过程流</font>
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230908102833211.png" alt="image-20230908102833211" style="zoom:50%;" />
     **采用循环的方式执行各个活动，每次循环都能产生更为完善的软件版本**
   - <font color='#66ccff'>并行过程流</font>
     <img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230908102757050.png" style="zoom:50%;" />
     **将一个或者多个活动与其他活动并行执行**

## 3.2 定义框架活动 ?

对于由个人负责的小型软件项目，其需求简单明确，沟通(活动)也许仅仅是与合适的利益相关者打个电话。所以主要的动作 (一个动作)就是电话交流，其主要工作任务集有：

1. 通过电话与利益相关者取得联系；

2. 讨论需求并做记录；

3. 将笔记整理成一份简单的书面需求；

4. 通过E-mail，请利益相关者审阅并批准。

多个利益相关者 + 多个需求—>沟通活动会产生多个**动作**：

- 启动、需求获取、需求系统、谈判、规格说明与确认等

## 3.3 明确任务集 ?

## 3.4 过程模式

> 每个软件团队在软件过程里都会遇到很多问题。针对这些问题，如果软件团队能够得到已有的经过验证的解决方案，将有助于他们快速地分析和解决问题。

<font color='#66ccff'>过程模式（process pattern）</font>：描述了软件工程工作中遇到的**过程相关的问题**、明确了问题环境并给出了针对该问题的一种或几种可证明的**解决方案**。

通俗地讲，过程模式提供了一个模板—一种在软件过程的背景下，统一描述问题解决方案的方法。通过模式组合，软件团队可以解决问题并定义最符合项目需求的开发过程。

- 模式可以在不同抽象层次上进行定义：
  - 模式可以描述一个完整**过程模型**（例如原型开发）的相关问题与解决方案；
  - 模式也可以描述一个**框架活动**（例如策划）
  - 或者框架活动中的某一项**具体任务**（例如项目估算）的相关问题与解决方案；

#### Ambler过程过程模式模板

**模式名称**：应清楚地表达该模式在软件过程中的含义(如 技术评审)。

**驱动力(目的)**：模式使用环境及主要问题，以明确主要难点。

**类型**：步骤模式（定义框架活动）、任务模式 (定义软件工程动作或任务）、阶段模式（定义框架活动序列）

**启动条件**：模式应用前需满足的前提条件(输入) 。需要明确：

1. 在此之前，整个开发组织或者开发团队内已有哪些活动？
2. 已有哪些软件工程信息或是项目信息？
3. 过程的进入状态是什么？

**问题**：描述模式将要解决的具体问题。

**解决办法**：描述如何成功实现模式。

**结束条件**：描述模式成功执行之后的结果(输出)。模式结束时需要明确：

1. 必须完成哪些开发组织或是开发团队相关的活动？

2. 过程的结束状态是什么？

3. 产生了哪些软件工程信息或是项目信息？

**相关模式**：列举与该模式直接相关的其它过程模式。

**已知应用实例**：说明该模式可应用的具体实例。(什么场合使用)



#### 回归测试过程模式

**模式名称**：回归测试 (指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误)。

**目的**：构造一种测试的过程。

**类型**：任务模式。

**启动条件**：在模式启动之前必须满足以下三个条件：①原来的测试用例；②更新后的软件；③针对更新部分的新测试用例。

**问题**：要测试模块。

**解决方法**：先用原来的测试用例测试软件，再用新测试用例测试软件。

**结束条件**：完成测试的软件。

**相关模式**：测试、单元测试、系统测试。

**已知应用实例**：更新软件后建议使用。

# 第4章 过程模型

## 4.1 惯用过程模型

<font color='#66ccff'>惯用过程模型</font>

- 目标：使软件开发更加有序。
- 所有的软件过程模型都支持通用框架活动，但是每一个模型都对框架活动有不同的侧重。
- 也称<font color='#66ccff'>软件生存周期模型</font>。

### 4.1.1 瀑布模型

<font color='#66ccff'>瀑布模型</font>

- 将软件生存周期的各项活动规定为**按照固定顺序连接（瀑布般）**的若干阶段工作：即从**用户需求规格说明**开始，顺序地通过**沟通**、**策划**、**建模**、**构建**和**部署**过程，最终提供完整**软件**和持续**技术支持**。
- 前提：需求必须是**准确定义**和相对**稳定**的。
- 又称为<font color='#66ccff'>经典生命周期</font>。

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230909160806697.png" alt="image-20230909160806697" style="zoom: 33%;" /> 

特点：

- 阶段间具有**顺序性和依赖性**；<font color='orange'>(必须逐步完成)</font>
- **推迟实现**的观点：前面步骤完成后才考虑实现；
- **质量保证**的观点：每一阶段都需要有文档以及经过评审；

问题：

- 瀑布模型需要客户明确需求，但**客户难以准确表达所有需求**。

- **得到可执行程序的时间太迟**(项目接近尾声)，对于系统中存在的重大缺陷，如果在可执行程序评审之前没有被发现，将可能造成惨重损失。
- 可能导致一些**阻塞**(开发团队的一些成员要等待另一些成员工作完成，尤其在开始和结束阶段，花在等待的时间可能超过生产性工作时间)
- 过于**理想化**，难以应对开发过程中的各种不确定因素。

#### V模型

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230909161055184.png" alt="image-20230909161055184" style="zoom:50%;" /> 

瀑布模型即为↘过程, 编码结束后, 团队沿着↗推进

本质是**加了一系列测试**(质量保证动作)

瀑布模型与V模型==没有本质区别==，V模型提供了一种将**验证确认动作应用于早期软件工程工作**中的方法。

### 4.1.2 增量模型

> 模型提出背景：
>
> - 需求不明确或迫切需要为用户**迅速提供**一套功能有限的软件产品，然后再后续版本中**再进行细化和扩展**功能。

增量模型综合了**线性过程流**和**并行过程流**的特征：

- 随着时间的推移，增量模型在每个阶段运用线性序列；
- 每个线性序列以一种演化过程流的方式生产出软件的可交付增量。

以==迭代==方式运用瀑布模式。

运用增量模型的时候，第一个增量往往是**核心产品（core product）**(满足基本需求)。但是许多附加的特性（可能已知, 可能未知）没有提供，客户使用该核心产品或者进行仔细的评价，并**根据评价结果制定下一个增量计划**。这份计划说明了需要对核心产品进行的修改，以便更好地满足客户的要求，也说明了**需要增加的特性和功能**。<font color='orange'>省流: 先做个够用的, 逐步添加功能</font> 

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230909162914978.png" alt="image-20230909162914978" style="zoom:50%;" /> 

增量开发的优点：

- 能在**较短时间**内向用户提交可完成**部分工作**的产品； 
- 用户有较充裕的时间**学习和适应**新产品；
- 易于**保证核心功能**正确；
- 可以基于早期版本来**获取需求**；
- 项目完全失败的**风险小**；
- 可以为那些创新的功能**开拓市场**；<font color='orange'>不是抢占市场?</font>
- **规避了资源缺乏**的风险；

问题：

- 把用户需求转化为功能递增的不同版本可能比较难 (功能联系紧密，难以完全分开)
- 难以确定所有版本共需的**公用模块**。(通常进行设计时会先考虑设计公用模块，但是每一个增量只考虑局部的设计，因此，全局的公用模块很难确定)

#### 迭代式开发

<img src="https://yj-notes.oss-cn-hangzhou.aliyuncs.com/image/image-20230909164144045.png" alt="image-20230909164144045" style="zoom:50%;" /> 

<font color='#66ccff'>迭代式开发</font>是增量式开发的一种变体，不同于传统的增量开发（每次提交一个构件），迭代式开发**开始提交所有的模块**（部分模块有待优化），在其后的阶段逐渐优化。

### 4.1.3 演化过程模型

> 提出背景：
>
> - 开发过程中，业务和产品需求经常变化；
> - 严格的交付时间使得开发团队不可能圆满完成软件产品，但是必须交付功能有限的版本以及应对竞争或商业压力；
> - 往往很好地理解了核心产品需求，但是系统扩展的细节问题却没有定义。

<font color='#66ccff'>演化模型</font>是**迭代的过程模型**，每次迭代产生软件的一个更完整的版本。

#### 原型开发



#### 螺旋模型



#### 演化模型的缺点

1. 由于构建产品的**迭代周期数目不确定**，原型开发（和其他更加复杂的演化过程）给项目计划带来了困难。大多数的项目管理和估算技术是基于活动的线性布局，所以并不完全适用于演化软件过程。
2. 演化模型**没有确定演化的最快速度**。如果演化的速度太快，完全没有间歇时间，项目肯定会陷入混乱；反之，如果演化速度太慢，则会影响生产率……

3. 演化模型**侧重灵活性和可延展性，而不是高质量**。这种说法听起来很惊人。演化模型优先追求开发速度，而不是零缺陷。

## 4.2 专用过程模型

<font color='#66ccff'>专用过程模型</font>具有传统过程模型的一些特点，但是专用过程模型往往应用面较窄而专一，只适用某些特定的软件工程方法。

### 4.2.1 构件开发模型

- 本质上是演化模型，具有多螺旋模型的特点，利用迭代方式构件软件；
  但与演化模型不同，基于构件开发模型采用**预先打包**的软件构件开发应用系统；

- 优点：能够使软件复用，减少项目开发费用，缩短开发周期

## 4.3 统一过程

## 4.4 产品和过程

## 过程模型回顾



# 第7章 理解需求

## 7.1 需求工程

### 软件需求

- 对期望的软件行为的表达。

- 分为功能需求、非功能需求：

  - 功能需求—描述系统预期提供的功能或服务：

    - 系统应提供的服务
    - 系统如何对输入做出反应

    - 系统在特定条件下的行为

    - 系统不应该做什么

    - 数据

  - 非功能需求：不直接与系统具体功能相关的需求：
    - 产品需求：产品行为的需求，包括性能需求、可靠性需求和可用性需求等。
    - 机构需求：客户和开发者所在机构中的政策和规定要求，如过程标准、实现要求、交付需求。
    - 外部需求：所有的系统外部因素要求，如互操作需求、道德需求。

### 需求工程

需求工程 (Requirement Engineering, RE)是指致力于不断理解需求的大量任务和技术。从软件过程的角度来看，需求工程是一个软件工程动作，开始于沟通活动并持续到建模活动。

需求工程在设计和构造之间建立起联系的桥梁 (×)：

- 由软件团队检查将要进行的软件工作的内容；
- 必须提交设计和构建的特定要求；
- 完成指导工作顺序的优先级定义；
- 会影响随后设计的信息、功能和行为。

两种需求过程：

- 瀑布式需求
  - 项目早期完全确定需求
- 进化式需求
  - 结合迭代开发，持续地寻找、记录、组织和跟踪不断变更的需求