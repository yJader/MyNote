# 并发编程的感悟

## 状态一致性

在你开启一个线程时, 如果创建者和子线程在逻辑(需求)上处于同一状态, 且二者都被同一把大锁保护
**请切记**, 在子线程启动时校验状态
- 因为创建者解锁后, 有可能有其他线程**先获取了锁**, 并修改了系统状态
- 如果子线程不校验状态, 可能会导致意想不到(且可能很难debug)的问题

如何发现这个问题?
- 如上文所述, 创建者解锁和子线程加锁之间的时间差会很小, 大概率能竞争到锁, 这导致FAILURE的概率很低(67/30000, 0.00223)
- 解决方式: 在跑测试时, 忘记关闭了Mutex的上锁解锁的log. 调用打印log函数这个过程的时间, 使得Mutex上锁解锁期间有更大的概率暴露出FAIL(提升到约30/2000)

## 并发Log

### 调试orLog
  
在分布式系统中, 许多failure是随机出现的(like 3/2000), 这时传统的按行调试就显得力不从心了(复现这个failure的难度不亚于解决这个failue)

这时候, 只能依靠脚本测试(python是简单快速的选择)+详尽的Log来定位问题, 加上你的仔细思考, 才能解决问题

### Log的取舍

Log过多, 会导致系统性能下降(但更好的一点是, 也更有高的概率暴露出系统的问题), 且会让你的Log分析思考更加困难
Log过少, 很直观的一点就是, 你无法定位问题
- 解决方案: 对Log进行分类, 并在系统开始时进行分类Log的开关, 在分析时也可以根据Log类型进行筛选和分析

Log的位置也很关键, 如果你的Log在关键点之后, 那么你的Log就失去了意义(有可能Failure已经发生, 但是你的Log还没有打出来)
- 在每一个关键点(like函数调用, 重要的if判断)**之前**打上Log
