# 并发编程的感悟

## 状态一致性

在并发环境中，状态一致性是保障系统正确性的重要因素。当一个线程创建了子线程并**共享某些状态**时，需要特别关注创建者与子线程之间的状态同步问题。

### 顺序执行中, 减少函数封装

>因为奇怪的个人喜好, 封装了过多的方法, 出现了一些问题

如果你实现的函数在caller前后要求状态一致, 并且在caller位置前还有一些需要加锁的额外操作, 那么
1. 不在函数内部加锁(即线程不安全), 由caller来进行加锁解锁操作
2. 部分需求可能要在函数内部解锁(如调用了其他可能阻塞的操作, ch <- msg), 那么说明这个函数设计的有问题, 最好不进行封装

### 校验状态的重要性

**切记**, 在子线程启动时校验状态
- 因为创建者解锁后, 有可能有其他线程**先获取了锁**, 并修改了系统状态
- 如果子线程不校验状态, 可能会导致意想不到(且可能很难debug)的问题
### 实践经验

>如何发现这个问题?

如上文所述, 由于创建者线程解锁和子线程加锁之间的时间差非常小，大部分情况下创建者和子线程都能成功竞争到锁，因此问题出现的概率极低。
- 在一次实验中，问题的复现概率仅为 67/30000（约 0.00223）
- **解决方式**: 通过对锁操作增加日志记录功能，使锁解锁和竞争的时间窗口变大，从而提高了问题暴露的概率，复现率提升到了约 30/2000。

## 并发Log

### 调试orLog
  
在分布式系统和并发编程中，许多错误（如竞争条件）具有随机性，可能在某些情况下只会出现几次（如 3/2000）。这使得传统按行调试的方式几乎无法胜任，因为复现失败本身就异常困难(复现这个failure的难度不亚于解决这个failue)。

在这种情况下，详尽的日志成为调试和问题定位的关键工具。结合自动化测试脚本（如使用 Python 快速编写），可以在高频测试中记录所有关键点的信息，再通过仔细分析和思考，找到问题根源。
- 相应的, test的实现也是一大难点

### Log的取舍

**日志过多**: 过多的日志会显著降低系统性能，尤其是在并发场景中，日志记录可能成为性能瓶颈。此外，过多的日志会导致分析负担过重，使得有效信息被淹没。
- 这样也有可能帮助暴露出系统的问题

**日志过少**: 相对地，过少的日志会直接导致无法定位问题，尤其是在复杂并发场景中，缺乏关键点的日志可能让问题排查无从下手。

### Log优化

- **日志级别**：通过经典的日志级别（如 DEBUG、INFO、WARN、ERROR），对日志的重要性进行分类，并根据需求动态调整记录的日志级别。
- **日志分类**：给日志设置不同的主题（Topic），在系统运行时按需打开或关闭特定类别的日志，从而减少不必要的日志输出。在分析阶段，也可以对日志类型进行筛选，从而专注于问题相关的数据。
- **关键点日志**：日志记录的位置至关重要。关键点之后的日志可能无意义，因为故障可能已经发生但日志尚未写入。通常，在函数调用前、重要条件判断前等关键点**之前**记录日志，以确保我们能够捕获导致故障的前置状态和环境信息。

## 死锁的解决

1. 对加锁&解锁操作打印Log
2. 在测试中缩短超时时间, 在超时时打印所有线程的栈
	- `go test -timeout=2m` 默认为10m 过长了, 不利于检查
	- 在kill时注意清理ch, 以减少不必要的线程栈
