# Lab4 Fault-tolerant Key/Value Service
## 实验文档

### 介绍

在这个实验中，您将使用在Lab 3中构建的Raft库来创建一个容错的Key/Value存储服务。您的Key/Value服务将是一个复制状态机，由多个Key/Value服务器组成，每个服务器维护一个Key/Value对数据库，类似于Lab 2中的情况，但额外使用Raft进行复制。您的Key/Value服务应该能够继续处理客户端请求，只要大多数服务器存活且可以相互通信，即使存在其他故障或网络分区。完成Lab 4后，您将实现所有部分（Clerk, Service, 和 Raft），如Raft交互图所示。

客户端将与您的Key/Value服务互动，方式与Lab 2大致相同。具体来说，客户端可以向Key/Value服务发送三种不同的远程过程调用（RPC）：

- `Put(key, value)`：替换数据库中特定键的值。
- `Append(key, arg)`：将`arg`追加到键的值后面（如果该键不存在，则将现有值视为空字符串）。
- `Get(key)`：获取键的当前值（对于不存在的键返回空字符串）。

键和值都是字符串。请注意，与Lab 2不同的是，`Put`和`Append`不应向客户端返回任何值。每个客户端通过一个具有`Put`/`Append`/`Get`方法的Clerk与服务通信。Clerk管理与服务器的RPC交互。

您的服务必须安排应用对Clerk `Get/Put/Append`方法的调用是线性化的。如果依次调用这些方法，它们应该表现得好像系统只有一个状态副本，并且每个调用都应该观察到前面一系列调用所隐含的状态修改。对于并发调用，返回值和最终状态必须与操作按照某个顺序逐一执行时相同。调用是并发的，如果它们在时间上有重叠：例如，如果客户端X调用了`Clerk.Put()`，而客户端Y调用了`Clerk.Append()`，然后客户端X的调用返回。一个调用必须观察到所有在其开始之前已完成的调用的效果。

为单个服务器提供线性化相对简单。如果是复制的服务，这会更困难，因为所有服务器必须为并发请求选择相同的执行顺序，必须避免使用不是最新的状态回复客户端，并且在故障恢复其状态时必须保留所有已确认的客户端更新。

本实验分为两部分。在第一部分A中，您将使用自己的Raft实现来实现一个复制的Key/Value服务，但不使用快照。在第二部分B中，您将使用从Lab 3D得到的快照实现，这将允许Raft丢弃旧的日志条目。请务必在各自的截止日期前提交每一部分。

您应该复习扩展的Raft论文，特别是第7节和第8节。为了获得更广泛的观点，可以参考Chubby, Paxos Made Live, Spanner, Zookeeper, Harp, Viewstamped Replication, 和 Bolosky et al. 的文章。

尽早开始。

开始
我们在`src/kvraft`目录下为您提供了一个骨架代码和测试案例。您需要修改`kvraft/client.go`, `kvraft/server.go`，以及可能的`kvraft/common.go`。

要开始，请执行以下命令。不要忘记使用`git pull`以获取最新软件版本。